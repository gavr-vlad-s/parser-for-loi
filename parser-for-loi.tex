\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{listings}
\lstset{inputencoding=utf8,extendedchars=false,keepspaces=true,language=C++} 

\usepackage{ccaption}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{syntax}
\usepackage{bytefield}
\usepackage{multicol}



\usepackage{algpseudocode}
\usepackage{graphicx}

\usepackage[dvipsnames,usenames]{color}
\usepackage{hyperref}
\hypersetup{unicode,breaklinks=true}
\usepackage{tikz}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri,calc,shapes.misc,shapes.geometric}
\usepackage{minted}
\usepackage{ifplatform}

\textheight 24.0cm
\textwidth 16cm

\voffset -2cm
\hoffset .0cm
\oddsidemargin 0.5mm
\evensidemargin 0.5mm
\topmargin -0.4mm
\righthyphenmin=2
\hfuzz=12.7pt
\makeatletter
%\renewcommand\section{\@startsection {section}{1}{\z@}%
%                                   {3.5ex \@plus 1ex \@minus .2ex}%
%                                   {2.3ex \@plus.2ex}%
%                                   {\normalfont\Large\bfseries}}
%\renewcommand{\thesection}{\arabic{section}}
\@addtoreset{equation}{section}
\@addtoreset{figure}{section}
\@addtoreset{table}{section}

%\newlength{\chaprule}
%\newlength{\ATchapskip}
%\setlength{\chaprule}{0.4\p@} \setlength{\ATchapskip}{10\p@} \advance \ATchapskip by -1\chaprule
%\renewcommand{\@makechapterhead}[1]{%
%    \ifdim\chaprule>6\p@ \setlength{\chaprule}{6\p@}\fi
%    \vspace*{\ATchapskip}%
%    %\noindent\rule{\textwidth}{\chaprule}\par%
%    %\vskip 10\p@
%    {\parindent \z@ \normalfont \ifnum \c@secnumdepth >\m@ne {\huge\bfseries \@chapapp\space \thechapter.}
%        %\par\nobreak
%        %\vskip 8\p@
%        \fi \interlinepenalty\@M \huge\bfseries #1\par\nobreak \vskip 10\p@
%        %\noindent\rule{\textwidth}{\chaprule}\par%
%        \vskip\ATchapskip }}

%\@addtoreset{lstlisting}{section}
\makeatother

\iflinux
\else
\ifwindows
\makeatletter
\newcommand{\minted@write@detok}[1]{%
  \immediate\write\FV@OutFile{\detokenize{#1}}}%

\newcommand{\minted@FVB@VerbatimOut}[1]{%
  \@bsphack
  \begingroup
    \FV@UseKeyValues
    \FV@DefineWhiteSpace
    \def\FV@Space{\space}%
    \FV@DefineTabOut
    %\def\FV@ProcessLine{\immediate\write\FV@OutFile}% %Old, non-Unicode version
    \let\FV@ProcessLine\minted@write@detok %Patch for Unicode
    \immediate\openout\FV@OutFile #1\relax
    \let\FV@FontScanPrep\relax
%% DG/SR modification begin - May. 18, 1998 (to avoid problems with ligatures)
    \let\@noligs\relax
%% DG/SR modification end
    \FV@Scan}
    \let\FVB@VerbatimOut\minted@FVB@VerbatimOut

\renewcommand\minted@savecode[1]{
  \immediate\openout\minted@code\jobname.pyg
  \immediate\write\minted@code{\expandafter\detokenize\expandafter{#1}}%
  \immediate\closeout\minted@code}
\makeatother
\fi
\fi


\newcommand{\dom}{\rm dom}
\newcounter{rem}[section]
\renewcommand{\therem}{\thesection.\arabic{rem}}
\newenvironment{Remark}{\par\refstepcounter{rem} \bf Замечание \therem. \sl}{\rm\par}
\renewcommand{\theequation}{\thesection.\arabic{equation}}
\renewcommand{\thefigure}{\thesection.\arabic{figure}}
\renewcommand{\thetable}{\thesection.\arabic{table}}
%\renewcommand{\thelstlisting}{\thesection.\arabic{lstlisting}}
\renewcommand{\lstlistingname}{Листинг}

\renewcommand{\theenumi}{\arabic{enumi}}
\renewcommand{\labelenumi}{\theenumi)}
\newcommand{\udc}[1]{УДК #1}

\newcounter{lem}[section]
\renewcommand{\thelem}{\thesection.\arabic{lem}}
\newenvironment{Lemma}{\par\refstepcounter{lem}\bf Лемма \thelem. \sl}{\rm\par}

\newcounter{cor}[section]
\renewcommand{\thecor}{\thesection.\arabic{cor}}
\newenvironment{Corrolary}{\par\refstepcounter{cor}\bf Следствие \thecor. \sl}{\rm\par}
\newcounter{theor}[section]
\renewcommand{\thetheor}{\thesection.\arabic{theor}}
\newenvironment{Theorem}{\par\refstepcounter{theor}\bf Теорема \thetheor. \sl}{\rm\par}
%\let \kappa=\ae
\newcommand{\diag}{\mathop{\rm diag}}
\newcommand{\epi}{\mathop{\rm epi}}
\newenvironment{Proof}{\par\noindent\bf Доказательство.\rm}{ \par}

\newcounter{exam}[section]
\renewcommand{\theexam}{\thesection.\arabic{exam}}
\newenvironment{Example}{\par\refstepcounter{exam}\bf Пример \theexam. \sl}{\rm\par}

\newcounter{prob}[section]
\renewcommand{\theprob}{\thesection.\arabic{prob}}
\newenvironment{Problem}{\par\refstepcounter{prob}\bf Задача \theprob. \sl}{\rm\par}

\newcounter{sol}[section]
\renewcommand{\thesol}{\thesection.\arabic{sol}}
\newenvironment{Solution}{\par\refstepcounter{sol}\bf Решение. \rm}{\rm\par}

\newcounter{defin}[section]
\renewcommand{\thedefin}{\thesection.\arabic{defin}}
\newenvironment{Definition}{\par\refstepcounter{defin}\bf Определение \thedefin.\sl}{\rm\par}

\newcounter{answ}[section]
\renewcommand{\theansw}{\thesection.\arabic{answ}}
\newenvironment{Answer}{\par\refstepcounter{answ}\theansw. \rm}{\rm\par}

\newcounter{exerc}[section]
\renewcommand{\theexerc}{\thesection.\arabic{exerc}}
\newenvironment{Exercise}{\par\refstepcounter{exerc}\bf Упражнение \theexerc.\sl}{\rm\par}

\newcounter{algor}[section]
\renewcommand{\thealgor}{\thesection.\arabic{algor}}
\newenvironment{Algorithm}[3]{\par\refstepcounter{algor}{\bf Алгоритм \thealgor. }{\sl #1}\par{\bf Вход: }{\sl #2}\par{\bf Выход: }\sl #3\par{\bf Метод.}\par}{\rm\par}

\newcommand{\ljoq}{<<}
\newcommand{\rjoq}{>>}
\newcommand{\vraisup}{\mathop{\rm vraisup}}
\newcommand{\pr}{\mathop{\rm pr}}
\newcommand{\sgn}{\mathop{\rm sgn}}
\newcommand{\epsclos}{\mathop{\text{$\varepsilon$--замыкание}}}
\newcommand{\move}{\mathop{\text{переход}}}
\newcommand{\closure}{\mathop{\text{ЗАМЫКАНИЕ}}}
\newcommand{\goto}{\mathop{\text{ПЕРЕХОД}}}
\newcommand{\ACTION}{\text{ДЕЙСТВИЕ}}
\newcommand{\GOTO}{\text{ПЕРЕХОД}}
\newcommand{\shift}[1]{\textbf{п}#1}
\newcommand{\reduce}[1]{\textbf{св}#1}
\newcommand{\access}{\textbf{доп}}
\captiondelim{. }



%\setcounter{page}{3}
%\setcounter{section}{1}


\makeatletter
\def\@seccntformat#1{\csname the#1\endcsname.\quad}
\makeatother

\algrenewcommand\algorithmicwhile{\textbf{пока}}
\algrenewcommand\algorithmicdo{\textbf{ }}
\algrenewcommand\algorithmicend{\textbf{конец}}
\algrenewcommand\algorithmicif{\textbf{если}}
\algrenewcommand\algorithmicthen{\textbf{то}}
\algrenewtext{EndIf}{\textbf{всё}}
\algrenewcommand\algorithmicfor{\textbf{для}}
\algrenewtext{ForAll}{\textbf{для всех }}
\algrenewcommand\algorithmicelse{\textbf{иначе}}
\algrenewtext{ElsIf}{\textbf{инес }}
\algrenewtext{Procedure}{\textbf{алг }}
\algrenewtext{EndProcedure}{\textbf{кон }}

\newcommand{\nad}[2]{\genfrac{}{}{0pt}{0}{#1}{#2}}

\newcommand{\nullable}{\mathop{\textit{зануляется}}}
\newcommand{\firstpos}{\mathop{\textit{первые}}}
\newcommand{\lastpos}{\mathop{\textit{последние}}}
\newcommand{\followpos}{\mathop{\textit{следующие}}}

\newcommand{\myor}{\mathop{\textbf{или}}}

\newcommand{\myand}{\mathop{\textbf{и}}}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\newcommand{\FIRST}{\text{ПЕРВЫЕ}}
\newcommand{\FOLLOW}{\text{СЛЕДУЮЩИЕ}}


\begin{document}
\unitlength=5mm

\author{Гаврилов Владимир Сергеевич}
\title{Пример реализации синтаксического анализатора}
\maketitle

    \tableofcontents


\section{Введение}
В данном тексте приводится пример реализации синтаксического анализатора, а именно реализации анализатора для варианта №5 по построению лексического анализатора. Студентам, у которых другой номер варианта, нужно видоизменить для своего случая то, что приводится ниже.

\section{Синтаксический анализатор для варианта №5}

Условимся, что все заголовочные файлы (а именно, файлы с расширением \texttt{.h}) располагаются в каталоге \texttt{include}, а файлы реализации (файлы с расширением \texttt{.cpp}) --- в каталоге \texttt{src}.
При этом условимся также, что написанный синтаксический анализатор будет порождать расположенное в памяти синтаксическое дерево обрабатываемой программы.

%Проект Мяука представляет собой генератор лексических анализаторов, порождающий текст лексического анализатора на языке C++. К данному моменту имеется достаточно много таких генераторов, например \href{http://www.ssw.uni-linz.ac.at/Coco}{Coco/R}, \href{http://flex.sourceforge.net}{flex}, \href{http://www.mario-konrad.ch/wiki/doku.php?id=programming:flexbison:flexppbisonpp}{flex++}, \href{http://flexcpp.sourceforge.net}{flexc++}, и этот список далеко не полон. Однако у всех этих генераторов есть один общий недостаток. Состоит указанный недостаток в том, что этими генераторами, по существу, автоматизируются лишь задачи проверки корректности записи и обнаружения начала лексем, а порождение значения лексемы по её строковому представлению должно выполняться вызываемой после проверки корректности лексемы функцией, написанной пользователем генератора. При этом, во–первых, дважды выполняется проход по фрагменту входной строки, и, во–вторых, приходится вручную реализовывать часть конечного автомата, построенного генератором лексических анализаторов. Предлагаемый генератор нацелен на устранение данного недостатка.
%
%\chapter{Сведения из теории формальных языков}
%Данная глава посвящена минимально необходимым для реализации лексического анализа сведениям из теории формальных языков и конечных автоматов.
%\section{Определение алфавитов и языков}
%Прежде всего приведём определение алфавита и языка.
%
%\textbf{Алфавитом} называется любое конечное множество некоторых символов. При этом понятие символа не определяется, поскольку оно в теории формальных языков является базовым.
%
%Как правило, алфавит будем обозначать заглавными греческими буквами (например, буквой $\Sigma$), возможно, с нижними индексами.
%
%Приведём примеры алфавитов:
%\begin{enumerate}
%    \item $\{0,1\}$ --- алфавит $\Sigma_1$, состоящий из нуля и единицы;
%
%    \item $\{A,B,\dots,Z\}$ --- алфавит $\Sigma_2$, состоящий из заглавных латинских букв;
%
%    \item $\{\text{А},\text{Б},\text{В},\text{Г},\text{Д},\text{Е},\text{Ё},\dots,\text{Я}\}$ --- алфавит $\Sigma_3$, состоящий из заглавных русских букв;
%
%    \item $\{$\textbf{int}, \textbf{void}, \textbf{return}, *, (, ), '\{', '\}', ;, main, \textit{number}$\}$ --- алфавит $\Sigma_4$, состоящий из ключевых слов \textbf{int}, \textbf{void},
%    \textbf{return} языка Си, идентификатора main, звёздочки, круглых скобок, фигурных скобок, точки с запятой, и целых чисел \textit{number} (синтаксис целых чисел --- как в языке Си);
%
%    \item $\{a_1,a_2,a_3,a_4\}$ --- алфавит $\Sigma_5$, состоящий из каких--то четырёх символов.
%\end{enumerate}
%
%Из символов алфавита можно составлять \textbf{строки}, то есть конечные последовательности символов. Если строка состоит из символов алфавита $\Sigma$, то её называют \textbf{строкой над
%    алфавитом $\Sigma$}. \textbf{Длиной строки} $x$ называется количество символов в этой строке. Длину строки $x$ будем обозначать $|x|$. Строка, вообще не содержащая символов, называется
%\textbf{пустой строкой} и будет обозначаться $\varepsilon$.
%
%Приведём примеры строк:
%\begin{enumerate}
%    \item 0111001 --- строка над алфавитом $\Sigma_1$;
%
%    \item ENGLISH, INTEL --- строки над алфавитом $\Sigma_2$;
%
%    \item МОСКВА, ГОРЬКИЙ, АЛЁШКОВО --- строки над алфавитом $\Sigma_3$;
%
%    \item \textbf{int} main (\textbf{void})'\{' \textbf{return} \textit{number}';' '\}' ---
%    строка над алфавитом $\Sigma_4$;
%
%    \item $a_1a_3a_2a_2a_4$ --- строка над алфавитом $\Sigma_5$.
%\end{enumerate}
%
%Далее потребуется операция \textbf{сцепления} (иногда говорят \textbf{конкатенации}) строк. Эта операция заключается в приписывании одной строки в конец другой. Например,
%если строки $\alpha$ и $\beta$ таковы, что $\alpha={abc}$, $\beta={defg}$, то сцепление строк $\alpha$ и $\beta$ обозначается $\alpha\beta$, и представляет собой строку ${abcdefg}$.
%
%Множество всех строк над алфавитом $\Sigma$ обозначается $\Sigma^*$. Скажем, если $\Sigma=\{0,1\}$, то $\Sigma^*=\{\varepsilon,0,1,00,01,10,11,000,\dots,1010,\dots\}$. Ясно,
%что множество всех строк над заданным алфавитом --- бесконечно.
%
%Любой набор строк над некоторым алфавитом называется \textbf{языком} (ещё называют \textbf{формальным языком}, чтобы отличать от естественных языков). Допустим, из всевозможных строк над алфавитом $\{0,1,2, 3,4,5,6,7,8,9,'.',-\}$ можно выбрать те, которые являются корректной записью некоторого вещественного числа:
%$L=\{0,-1.5,1002.123345,777,\dots\}$. Языки обозначаются заглавными латинскими буквами, возможно с нижними индексами. Язык может являться конечным множеством строк: если
%$L$ --- язык над алфавитом $\{a,b\}$, содержащий лишь строки состоящие из менее чем трёх символов, то $L=\{\varepsilon,a,b,aa,ab,ba,bb\}$.
%
%\section{Операции над языками и регулярные выражения}
%Поскольку язык --- это некоторое множество строк, то нужно уметь это множество как--то описывать. Одним из способов описания являются так называемые регулярные выражения.
%Прежде чем определить, что такое регулярное выражение, нужно определить операции над языками. Операции над языками, которые нам потребуются, собраны в табл.\ref{langops}.   %\newpage
%\begin{table}[!h]
%    \centering
%    \caption{Операции над языками.}\label{langops}
%    \vspace{1mm}
%    \begin{tabular}{|l|p{70mm}|}\hline
%        Операция                                                & Определение и обозначение операции            \\ \hline
%        Объединение $L$ и $M$                                   & $L\cup M=\{s: s\in L\text{ или }s\in M\}$     \\ \hline
%        Сцепление $L$ и $M$                                     & $LM=\{st: s\in L\text{ и }t\in M\}$           \\ \hline
%        Замыкание Клин\'{и} языка $L$                           & $L^*=\bigcup\limits_{i=0}^\infty L^i$         \\ \hline
%        Положительное замыкание языка $L$                       & $L^+=\bigcup\limits_{i=1}^\infty L^i$         \\ \hline
%    \end{tabular}
%\end{table}
%
%В этой таблице  $L$ и $M$ --- некоторые языки над алфавитом $\Sigma$. Кроме того, в таблице используется обозначение $L^i$, которое означает следующее: $L^0=\{\varepsilon\}$,
%$L^i=\underbrace{L\dots L}_{\text{$i$ раз}}$.
%
%\begin{Definition}
%    Регулярные выражения строятся из подвыражений, в соответствии с описанными ниже правилами. В этих правилах через $L(r)$ обозначен язык, описываемый регулярным выражением
%    $r$. Правила    построения регулярных выражений таковы:
%    \begin{enumerate}
%        \item $\varepsilon$ --- регулярное выражение, и $L(\varepsilon)=\{\varepsilon\}$;
%        \item если $a$ --- символ алфавита $\Sigma$, то $a$ --- регулярное выражение, и $L(a)=\{a\}$;
%        \item если $r$ и $s$ --- регулярные выражения, то $(r)|(s)$ --- тоже регулярное выражение, и $L((r)|(s))=L(r)\cup L(s)$;
%        \item если $r$ и $s$ --- регулярные выражения, то и $(r)(s)$ --- регулярное выражение, причём $L((r)(s))=L(r)L(s)$;
%        \item если $r$ --- регулярное выражение, то $(r)^*$ также является регулярным выражением, и $L((r)^*)=(L(r))^*$;
%        \item если $r$ --- регулярное выражение, то и $(r)$ --- регулярное выражение, причём $L((r))=L(r)$;
%        \item ничто иное не является регулярным выражением.
%    \end{enumerate}
%\end{Definition}
%
%Записанные в соответствии с этим определением регулярные выражения часто содержат лишние пары скобок. Многие скобки можно опустить, если принять следующие соглашения:
%\begin{enumerate}
%    \item унарный оператор ${}^*$ --- левоассоциативен (т.е. выполняется слева направо) и имеет наивысший приоритет;
%    \item сцепление имеет второй по величине приоритет и также левоассоциативно;
%    \item оператор $|$ --- левоассоциативен, и имеет наименьший приоритет.
%\end{enumerate}
%\noindent%
%Пользуясь данными соглашениями, регулярное выражение $(a)|((b)^*c)$ можно переписать в виде $a|b^*c$.
%
%Приведём примеры регулярных выражений.
%\begin{Example}Пусть $\Sigma=\{a,b\}$. Тогда
%    \begin{enumerate}
%        \item регулярное выражение $a|b$ описывает язык $\{a,b\}$;
%        \item регулярное выражение $(a|b)(a|b)$ описывает язык $\{aa,ab,ba,bb\}$ над алфавитом $\Sigma$; другое регулярное выражение для того же языка --- $aa|ab|ba|bb$;
%        \item регулярное выражение $a^*$ описывает язык, состоящий из всех строк из нуля или более символов $a$, т.е. язык $\{\varepsilon,a,aa,aaa,\dots\}$;
%        \item регулярное выражение $(a|b)^*$ описывает множество всех строк из символов $a$ и $b$: $\{\varepsilon,a,b,aa,ab,\\ ba,bb,aaa,\dots\}$; другое регулярное выражение
%        для того же языка: $(a^*|b^*)^*$;
%        \item регулярное выражение $a|a^*b$ описывает язык $\{a,b,ab,aab,aaab,\dots\}$.
%    \end{enumerate}
%\end{Example}
%
%Язык, который может быть определён регулярным выражением, называется \textbf{регулярным языком}. Если два регулярных выражения, $r$ и $s$, описывают один и тот же язык, то
%выражения $r$ и $s$ называются \textbf{эквивалентными}, что записывается как $r=s$. Для регулярных выражений есть ряд алгебраических законов, каждый из которых заключается в
%утверждении об эквивалентности двух разных регулярных выражений. В табл.\ref{pp} приведены некоторые такие законы. Другие алгебраические законы для регулярных выражений
%можно найти, например, в \cite{HopkroftMotvaniUllman}.
%\begin{table}[!h]
%\centering
%\vspace{1mm}
%\caption{Некоторые алгебраические законы для регулярных выражений.}\label{pp}
%\begin{tabular}{|l|p{112mm}|}\hline
%    Закон                                               & Описание                                                                     \\ \hline
%    $r|s=s|r$                                           &  Оператор $|$ --- коммутативен.                                              \\ \hline
%    $r|(s|t)=(r|s)|t$                                   &  Оператор $|$ --- ассоциативен.                                              \\ \hline
%    $r(st)=(rs)t$                                       & Сцепление --- ассоциативно.                                                  \\ \hline
%    {\parbox[t]{25mm}{$r(s|t)=rs|rt$\\ $(s|t)r=sr|tr$}} & Сцепление дистрибутивно относительно оператора $|$.                          \\ \hline
%    $\varepsilon r=r\varepsilon=r$                      & $\varepsilon$ является нейтральным элементом по отношению к сцеплению строк. \\ \hline
%    $r^*=(r|\varepsilon)^*$                             & $\varepsilon$ гарантированно входит в  замыкание Клин\'{и}.                  \\ \hline
%    $(r^*)^*=r^*$                                       & Оператор ${}^*$ --- идемпотентен.                                            \\ \hline
%\end{tabular}
%\end{table}
%
%Для удобства записи регулярным выражениям можно присваивать имена и использовать затем эти имена в последующих выражениях так, как если бы это были символы. Если $\Sigma$
%--- некоторый алфавит, то \textbf{регулярным определением} называется последовательность определений вида
%\begin{gather*}
%    d_1\to r_1\\
%    d_2\to r_2\\
%    \dots\\
%    d_n\to r_n
%\end{gather*}
%Здесь
%\begin{enumerate}
%    \item каждое $d_i$ --- новый символ, не входящий в $\Sigma$ и не совпадающий ни с каким иным $d_i$;
%    \item каждое $r_i$ при $i>1$ --- регулярное выражение над алфавитом $\Sigma\cup\{d_1,\dots,d_{i-1}\}$, а $r_1$ --- регулярное выражение над алфавитом $\Sigma$.
%\end{enumerate}
%
%\begin{Example}
%Идентификаторы языка Си представляют собой строки из латинских букв, десятичных цифр, и знаков подчёркивания, причём идентификатор не должен начинаться с десятичной цифры.
%С помощью регулярных определений это можно записать так:
%\begin{align*}
%    \text{буква}\to&A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|\\
%                   &a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z\\
%\end{align*}
%\vspace{-16.1mm}
%\begin{align*}
%    &\text{буква_или_подчерк}\to\text{буква}|\_\\
%    &\text{цифра}\to0|1|2|3|4|5|6|7|8|9\\
%    &\text{идентификатор}\to\text{буква_или_подчерк}(\text{буква_или_подчерк}|\text{цифра})^*
%\end{align*}
%\end{Example}
%
%\begin{Example}
%Пусть беззнаковые числа (целые и с плавающей запятой) представляют собой строки вида $5280$; $0.01234$; $6.336E4$; $1.89E-4$. Точную спецификацию этого множества строк можно
%записать в виде следующего регулярного определения:
%\begin{align*}
%    &\text{цифра}\to0|1|2|3|4|5|6|7|8|9\\
%    &\text{цифры}\to\text{цифра}\,\,\text{цифра}^*\\
%    &\text{необяз_дробная_часть}\to.\text{цифры}|\varepsilon\\
%    &\text{необяз_экспонента}\to E(+|-|\varepsilon)\text{цифры}|\varepsilon\\
%    &\text{число}\to\text{цифры}\,\,\text{необяз_дробная_часть}\,\, \text{необяз_экспонента}
%\end{align*}
%\end{Example}
%
%С тех пор, как в 1950--х Клин\'{и} ввёл регулярные выражения с базовыми операторами объединения, сцепления, и замыкания Клин\'{и}, к регулярным выражениям добавлено много
%расширений, о которых можно прочитать, скажем, в \cite{FridlJ}. Упомянем лишь некоторые из них.
%
%1) \textit{Один или несколько экземпляров. }Унарный постфиксный оператор ${}^+$ представляет положительное замыкание регулярного выражения и его языка. Иначе говоря, если
%$r$ --- регулярное выражение, то $(r)^+$ описывает язык $(L(r))^+$. Опрератор ${}^+$ имеет те же приоритет и ассоциативность, что и оператор ${}^*$. Замыкание Клин\'{и} и
%положительное замыкание связывают два алгебраических закона: $r^*=r^+|\varepsilon$ и $r^+=rr^*=r^*r$.
%
%2) \textit{Нуль или один экземпляр. }Унарный постфиксный оператор $?$ означает \glqq нуль или один экземпляр\grqq, то есть запись $r?$ представляет собой сокращение для
%$r|\varepsilon$. Иными словами, $L(r?)=L(r)\cup\{\varepsilon\}$. Оператор $?$ имеет те же приоритет и ассоциативность, что и операторы ${}^*$ и ${}^+$.
%
%3) \textit{Классы символов. }Регулярное выражение $a_1|\dots|a_n$, где $a_i$, $i=\overline{1,n}$, --- символы алфавита, можно переписать сокращённо: $[a_1\dots a_n]$. При
%этом если символы $a_1,\dots,a_n$ образуют логическую последовательность (например, последовательные прописные буквы, последовательные строчные буквы, десятичные цифры), то
%выражение $a_1|\dots|a_n$ можно заменить выражением $[a_1-a_n]$. Например, $a|b|c$ можно переписать в виде $[abc]$, а $a|\dots|z$ --- в виде $[a\dots z]$ или $[a-z]$.
%
%Приведём примеры использования этих трёх расширений.
%\begin{Example}
%С помощью указанных расширений определение идентификаторов языка Си можно записать так:
%\begin{align*}
%    &\text{буква}\to[A-Za-z]\\
%    &\text{буква_или_подчерк}\to\text{буква}|\text{_}\\
%    &\text{цифра}\to[0-9]\\
%    &\text{идентификатор}\to\text{буква_или_подчерк}(\text{буква_или_подчерк}|\text{цифра})^*
%\end{align*}
%Определение же беззнаковых чисел можно переписать так:
%\begin{align*}
%    &\text{цифра}\to[0-9]\\
%    &\text{цифры}\to\text{цифра}^+\\
%    &\text{число}\to\text{цифры}(.\text{цифры})?(E[{+-}]?\text{цифры})?
%\end{align*}
%\end{Example}
%
%\begin{Exercise} Опишите языки, соответствующие следующим регулярным выражениям:
%{\renewcommand{\theenumi}{\asbuk{enumi}}
%\begin{enumerate}
%    \item $a(a|b)^*a$;
%    \item $((\varepsilon|a)b^*)^*$;
%    \item $(a|b)^*a(a|b)(a|b)$;
%    \item $a^*ba^*ba^*ba^*$;
%    \item $(aa|bb)^*((ab|ba)(aa|bb)^*(ab|ba)(aa|bb)^*)^*$.
%\end{enumerate}
%}
%\end{Exercise}
%
%\begin{Exercise} Запишите классы символов для следующих множеств:
%{\renewcommand{\theenumi}{\asbuk{enumi}}
%\begin{enumerate}
%    \item первые десять букв русского алфавита, как в верхнем, так и в нижнем регистре;
%    \item строчные согласные русского алфавита;
%    \item цифры шестнадцатиричного числа (для цифр, б\'{о}льших 9, могут использоваться как строчные, так и прописные буквы);
%    \item символы, которые могут находиться в конце корректного предложения на русском языке.
%\end{enumerate}}
%\end{Exercise}
%
%\section{Конечные автоматы}
%На данный момент мы знаем, что регулярный язык --- это язык, определяемый регулярным выражением. Однако встаёт вопрос: как определять, принадлежит ли строка регулярному
%языку или нет (или, как ещё говорят, как распознавать регулярные языки)?
%
%Запрограммировать распознавание позволяют \textbf{конечные автоматы}. Прежде всего скажем о \textbf{детерминированных конечных автоматах}.
%
%Автомат --- это некоторое устройство с конечным числом состояний. Среди всех состояний можно выделить \glqq особые\grqq: это \textbf{начальное} состояние, и одно или более
%\textbf{допускающих} (или \textbf{конечных}) состояний. Начальное состояние --- это состояние, в котором автомат находится в момент запуска. На вход автомата подаются
%символы некоторого алфавита. В зависимости от поданного на вход символа и текущего состояния автомат либо переходит в другое состояние, либо остаётся в текущем состоянии.
%Если пара (состояние, входной символ) однозначно определяет используемое правило перехода, то автомат называется \textbf{детерминированным}.
%
%Дадим теперь формальное определение конечного автомата.
%\begin{Definition}
%\textbf{Конечным автоматом} (сокращённо КА) называется пятёрка $M(Q,\Sigma,\delta,\\ q_0,F)$, в которой
%
%$Q$ --- конечное множество состояний автомата;
%
%$\Sigma$ --- конечное множество допустимых входных символов (алфавит автомата);
%
%$\delta$ --- функция переходов, отображающая произведение $Q\times\Sigma$ во множество всех подмножеств множества $Q$, то есть $\delta:Q\times\Sigma\to\mathcal{P}(Q)$;
%
%$q_0\in Q$ --- начальное состояние автомата;
%
%$F$ --- непустое множество конечных состояний, $F\subseteq Q$, $F\neq\emptyset$.
%
%Если функция $\delta$ определена на всём множестве $Q\times\Sigma$, то конечный автомат называется \textbf{полностью определённым}.
%
%Если при всех $(q,a)\in Q\times\Sigma$ имеется не более одного состояния, в которое переходит КА, то автомат называется \textbf{детерминированным} (сокращённо --- ДКА). В
%противном случае автомат называется \textbf{недетерминированным} (сокращённо --- НКА). Кроме того, у НКА могут быть переходы по $\varepsilon$.
%\end{Definition}
%
%Функцию переходов $\delta$ можно задать таблицей. Такая таблица называется \textbf{таблицей переходов}. Ниже приведён пример таблицы переходов.
%\begin{table}[!h]
%\centering
%\caption{Пример таблицы переходов для ДКА.}\label{Goto.table.example}
%\vspace{1mm}
%\begin{tabular}{|l|c|c|c|l|}  \hline
%    & $a$   & $b$  & $c$     & Примечание           \\  \hline
%1   & 5     &      & 1       &                      \\  \hline
%2   &       & 4    & 1       & конечное состояние   \\  \hline
%3   &       &      & 1       & начальное состояние  \\  \hline
%4   & 3     &      &         &                      \\  \hline
%5   & 2     &      &         &                      \\  \hline
%\end{tabular}
%\end{table}
%
%В этой таблице в первом столбце указаны имена состояний автомата (в данном случае --- просто числа), а $a$, $b$, $c$ --- символы, из которых состоит алфавит автомата. На
%пересечении строки с именем состояния и столбца, соответствующего символу алфавита, указано состояние, в которое переходит автомат. Например, на пересечении строки с именем
%2 и столбца с именем $b$ стоит 4. Следовательно, $\delta(2,b)=4$. Если какая--либо ячейка пуста, то это означает, что соответствующего перехода нет.
%
%Кроме того, переходы автомата можно задать с помощью ориентированного графа, вершинами которого являются состояния, а рёбрами --- переходы. Такой граф называется
%\textbf{диаграммой переходов} конечного автомата. На следующем рисунке изображён пример диаграммы переходов.
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=0.5pt,semithick},
%    post/.style={->,shorten >=0.5pt,semithick},
%    state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%    fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%    \matrix[row sep=7mm,column sep=7mm] {
%                                 &                        &                     & \node[state] (s3) {3}; & \node (fictive) {};    \\
%                                 & \node[state] (s1) {1}; &                     &                        &                        \\
%          \node[state] (s5) {5}; &                        & \node[fs] (s2) {2}; &                        & \node[state] (s4) {4}; \\
%    };
%    \path (fictive) edge [post]                                     (s3)
%    (s3)      edge [post]                 node[auto,swap] {$c$} (s1)
%    (s4)      edge [post]                 node[auto,swap] {$a$} (s3)
%    (s2)      edge [post]                 node[auto]      {$b$} (s4)
%              edge [post]                 node[auto,swap] {$c$} (s1)
%    (s5)      edge [post]                 node[auto]      {$a$} (s2)
%    (s1)      edge [post]                 node[auto,swap] {$a$} (s5)
%              edge [post, loop above]     node[auto]      {$c$} ();
%    \end{tikzpicture}}
%\vspace{-2mm}
%\caption{Пример диаграммы переходов ДКА.}\label{Transition.diagramm.example}
%\end{figure}
%
%Здесь круги обозначают состояния, причём круги с двойной рамкой --- конечные состояния; надпись над стрелкой обозначает символ, по которому совершается переход;
%переход выполняется из состояния в начале стрелки в состояние в конце стрелки. Стрелкой, не идущей ни из какого состояния, помечено начальное состояние автомата.
%
%\subsection{Преобразование недетерминированного автомата в детерминированный}
%Из определения конечного автомата следует, что любой ДКА является НКА. Обратное, вообще говоря, неверно. Однако доказано (см. \cite{AhoLamSetiUllman,HopkroftMotvaniUllman}),
%что любой НКА можно преобразовать в распознающий тот же язык ДКА.
%
%Идея преобразования состоит в том, что каждое состояние строящегося ДКА соответствует множеству состояний исходного, недетерминированного, автомата. После чтения входной
%строки $a_1a_2\dots a_n$ построенный ДКА находится в состоянии, соответствующем множеству состояний, которых может достичь исходный автомат по пути, помеченному строкой
%$a_1a_2\dots a_n$. Возможна ситуация, когда количество состояний построенного ДКА экспоненциально зависит от количества состояний исходного, недетерминированного, автомата.
%Однако при лексическом анализе реальных языков такого не бывает.
%
%Прежде чем сформулировать алгоритм преобразования НКА в ДКА, с помощью приводимой ниже таблицы опишем необходимые для этого алгоритма операции.
%\begin{table}[!h]
%\centering
%\caption{Операции для алгоритма преобразования НКА в ДКА.}\label{Ops.for.conversion!table}
%\vspace{1mm}
%\begin{tabular}{|l|p{108mm}|}  \hline
%Операция      & Описание \\  \hline
%$\epsclos(s)$ & Множество состояний НКА, достижимых из состояния $s$ по $\varepsilon$--переходам. При этом всегда $s\in\epsclos(s)$.  \\  \hline
%$\epsclos(T)$ & $\bigcup\limits_{s\in T}\epsclos(s)$ ($T$ --- множество состояний)                                                    \\  \hline
%$\move(T,a)$  & Множество состояний НКА, в которые имеется переход из некоторого состояния $s\in T$ по символу $a$.                   \\  \hline
%\end{tabular}
%\end{table}
%
%Приведём теперь сам алгоритм построения ДКА по НКА.
%\begin{Algorithm}{Построение ДКА по НКА.}{НКА $M(Q,\Sigma,\delta,q_0,F)$.}{ДКА $M'(Q',\Sigma,\delta',q_0',F')$.}\label{NDFA.to.DFA}
%Изначально в $Q'$ имеется лишь одно состояние, $\epsclos(q_0)$, и оно не помечено. Далее делаем так:
%\begin{algorithmic}
%\While {в $Q$ есть непомеченное состояние $T$}
%  \State {пометить $T$}
%  \ForAll {$a\in\Sigma$}
%    \State {$U\gets\epsclos(\move(T,a))$}
%    \If{$U\notin Q'$}
%      \State {добавить $U$ в $Q'$ как непомеченное состояние}
%      \State {положить $\delta'(T,a)=U$}
%    \EndIf
%  \EndFor
%\EndWhile
%\end{algorithmic}
%
%Вычисление $\varepsilon$--замыкания множества состояний $T$ производится следующим образом:
%\begin{algorithmic}
%\State поместить все состояния множества $T$ в стек $stack$
%\State инициализировать $\epsclos(T)$ множеством $T$
%\While {$stack$ не пуст}
%  \State{снять со стека верхний элемент, $t$}
%  \ForAll {состояний $u$ с дугой от $t$ к $u$, помеченной $\varepsilon$}
%    \If{$u\notin\epsclos(T)$}
%      \State добавить $u$ во множество $\epsclos(T)$
%      \State поместить $u$ в $stack$
%    \EndIf
%  \EndFor
%\EndWhile
%\end{algorithmic}
%
%Допускающими состояниями построенного автомата будут те состояния $T\in Q'$, для которых $T\cap F\neq\emptyset$.
%\end{Algorithm}
%
%Приведём пример применения этого алгоритма.
%\begin{Example}
%Рассмотрим следующий недетерминированный КА, допускающий язык $(a|b)^*abb$ ($\Sigma=\{a,b\}$):
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%pre/.style={<-,shorten <=1pt,semithick},
%post/.style={->,shorten >=1pt,semithick},
%state/.style={circle,draw=black,,thick, inner sep=0pt,minimum size=6mm},
%fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%\matrix[row sep=7mm,column sep=7mm] {
%                    &                        &                        & \node[state] (s2) {2}; & \node[state] (s3) {3}; &                          &                        &                        &                        &                       \\
%    \node (sm1) {}; & \node[state] (s0) {0}; & \node[state] (s1) {1}; &                        &                        & \node[state] (s6) {6};   & \node[state] (s7) {7}; & \node[state] (s8) {8}; & \node[state] (s9) {9}; & \node[fs] (s10) {10}; \\
%                    &                        &                        & \node[state] (s4) {4}; & \node[state] (s5) {5}; &                          &                        &                        &                        &                       \\
%};
%\path (sm1) edge [post] (s0)
%      (s0)  edge [post] node[auto] {$\varepsilon$} (s1)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s2)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s4)
%      (s2)  edge [post] node[auto] {$a$} (s3)
%      (s4)  edge [post] node[auto] {$b$} (s5)
%      (s3)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s5)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s6)  edge [post] node[auto] {$\varepsilon$} (s7)
%      (s7)  edge [post] node[auto] {$a$} (s8)
%      (s6)  edge [post, skip loop=26mm] (s1)
%      (s0)  edge [post, skip loop=-26mm] (s7);
%\node at (-1.5,2.9) {$\varepsilon$};
%\node at (-1.5,-2.3) {$\varepsilon$};
%\path (s8) edge[post] node[auto] {$b$} (s9)
%      (s9) edge[post] node[auto] {$b$} (s10);
%\end{tikzpicture}}
%\caption{Диаграмма переходов НКА, допускающего язык $(a|b)^*abb$.}\label{NDFA.example}
%\end{figure}
%
%Построим по этому НКА, пользуясь алгоритмом \ref{NDFA.to.DFA}, соответствующий ДКА.
%
%Прежде всего, начальным состоянием будет $A=\epsclos(0)=\{0,1,2,4,7\}$. Вычислим $\delta'(A,a)\equiv\epsclos(\move(A,a))$.
%
%Среди состояний $\{0,1,2,4,7\}$ только у состояний 2 и 7 есть переход по символу $a$ (в состояния 3 и 8 соответственно). Поэтому $\move(A,a)=\{3,8\}$. Далее, из состояния 3
%можно с помощью $\varepsilon$--переходов дойти в состояния 3, 6, 7, 1, 2, 4; а из состояния 8 --- только в состояние 8. Поэтому $\epsclos(\move(A,a))=\{1,2,3,4,6,7,8\}$.
%Обозначим это множество $B$. Поскольку конечное состояние НКА, 10, множеству $B$ не принадлежит, то $B$ конечным состоянием не является.
%
%Вычислим $\delta'(A,b)\equiv\epsclos(\move(A,b))$. Среди всех состояний множества $A$ только у состояния 4 есть переход по символу $b$. Это переход в состояние 5. А из
%состояния 5 по $\varepsilon$--переходам можно дойти в сос\-то\-я\-ния 5, 6, 7, 1, 2, 4. Значит $\delta'(A,b)\equiv\epsclos(\move(A,b))=\epsclos(\{5\})=\{1,2,4,5,6,7\}$.
%Обозначим данное множество $C$.
%
%Последующие выкладки выглядят так:
%\begin{align*}
%\delta'(B,a)&=\epsclos(\move(B,a))=\epsclos(\move(\{1,2,3,4,6,7,8\},a))=\\
%            &=\epsclos(\move(\{2,7\},a))=\epsclos(\{3,8\})=B;\\
%\delta'(B,b)&=\epsclos(\move(B,b))=\epsclos(\move(\{1,2,3,4,6,7,8\},b))=\\
%            &=\epsclos(\move(\{4,8\},b))=\epsclos(\{5,9\})=\{1,2,4,5,6,7,9\}\equiv D;\\
%\delta'(C,a)&=\epsclos(\move(C,a))=\epsclos(\move(\{1,2,4,5,6,7\},a))=\\
%            &=\epsclos(\move(\{2,7\},a))=B;\\
%\delta'(C,b)&=\epsclos(\move(C,b))=\epsclos(\move(\{1,2,4,5,6,7\},b))=\\
%            &=\epsclos(\move(\{4\},b))=\epsclos(\{5\})=C; \\
%\delta'(D,a)&=\epsclos(\move(D,a))=\epsclos(\move(\{1,2,4,5,6,7,9\},a))=\\
%            &=\epsclos(\move(\{2,7\},a))=B;\\
%\delta'(D,b)&=\epsclos(\move(D,b))=\epsclos(\move(\{1,2,4,5,6,7,9\},b))=\\
%            &=\epsclos(\move(\{4,9\},a))=\epsclos(\{5,10\})=\{1,2,4,5,6,7,10\}\equiv E; \\
%\delta'(E,a)&=\epsclos(\move(E,a))=\epsclos(\move(\{1,2,4,5,6,7,10\},a))=\\
%            &=\epsclos(\move(\{2,7\},a))=B; \\
%\delta'(E,b)&=\epsclos(\move(E,b))=\epsclos(\move(\{1,2,4,5,6,7,10\},b))=\\
%            &=\epsclos(\move(\{4\},b))=C
%\end{align*}
%Соберём эти результаты в таблице переходов:%\newpage
%\begin{table}[!h]
%    \centering
%    \caption{Таблица переходов ДКА, распознающего язык $(a|b)^*abb$.}\label{DFA.for.(a|b)ast.abb}
%    \vspace{1mm}
%    \begin{tabular}{|l|c|c|c|l|}  \hline
%        Множество состояний НКА     & Состояние ДКА & $a$   & $b$     & Примечание           \\  \hline
%        $\{0,1,2,4,7\}$             & $A$           & $B$   & $C$     & начальное состояние  \\  \hline
%        $\{1,2,3,4,6,7,8\}$         & $B$           & $B$   & $D$     &                      \\  \hline
%        $\{1,2,4,5,6,7\}$           & $C$           & $B$   & $C$     &                      \\  \hline
%        $\{1,2,4,5,6,7,9\}$         & $D$           & $B$   & $E$     &                      \\  \hline
%        $\{1,2,4,5,6,7,10\}$        & $E$           & $B$   & $C$     & конечное состояние   \\  \hline
%    \end{tabular}
%\end{table}
%
%Приведём диаграмму переходов, построенную по этой таблице:
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%pre/.style={<-,shorten <=0.5pt,semithick},
%post/.style={->,shorten >=0.5pt,semithick},
%state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%\matrix[row sep=7mm,column sep=12mm] {
%                        &                          & \node[state] (sC) {$C$}; &                          &                       \\
%                        &                          &                          &                          &                       \\
%                        &                          &                          &                          &                       \\
%                        &                          &                          &                          &                       \\
%    \node (fictive) {}; & \node[state] (sA) {$A$}; & \node[state] (sB) {$B$}; & \node[state] (sD) {$D$}; & \node[fs] (sE) {$E$}; \\
%};
%\path (fictive) edge [post]                                                (sA)
%      (sA)      edge [post]                        node[auto]        {$b$} (sC)
%                edge [post]                        node[auto]        {$a$} (sB)
%      (sC)      edge [post]                        node[auto]        {$a$} (sB)
%                edge [post, loop above]            node[auto]        {$b$} ()
%      (sE)      edge [post]                        node[auto,swap]   {$b$} (sC)
%                edge [post, skip loop=-12mm]                               (sB)
%      (sD)      edge [post]                        node[auto]        {$b$} (sE)
%                edge [post, bend left=17]          node[right, auto] {$a$} (sB)
%      (sB)      edge [post, bend left=17]          node[left, auto]  {$b$} (sD)
%                edge [post, in=120, out=150, loop] node[auto]        {$a$} ();
%\node at (1.7,-2.6) {$a$};
%\end{tikzpicture}}
%\caption{Диаграмма переходов ДКА, допускающего язык $(a|b)^*abb$.}\label{diagramm.for.DFA.for.(a|b)ast.abb}
%\end{figure}
%\end{Example}
%
%\subsection{Моделирование конечного автомата}
%Приведём теперь алгоритмы работы конечных автоматов. Начнём с детерминированных автоматов.
%\begin{Algorithm}{Моделирование ДКА.}{входная строка $x$ с завершающим символом eof и ДКА $M$ с начальным состоянием $q_0$, набором принимающих состояний $F$ и
%функцией переходов $\delta$.}{ ответ \glqq да\grqq, если автомат $M$ принимает строку $x$, и ответ \glqq нет\grqq\ --- в противном случае.}
%\begin{algorithmic}
%\State{$s\gets q_0$}
%\State{$c\gets\text{следующий_символ}()$}
%\While{$c\neq\text{eof}$}
%   \State{$s\gets\delta(s,c)$}
%   \State{$c\gets\text{следующий_символ}()$}
%\EndWhile
%\If{$s\in F$}
%   \State{выдать \glqq да\grqq}
%\Else
%   \State{выдать \glqq нет\grqq}
%\EndIf
%\end{algorithmic}
%\end{Algorithm}
%
%А теперь приведём алгоритм работы НКА.
%\begin{Algorithm}{Моделирование НКА.}{входная строка $x$ с завершающим символом eof и НКА $M$ с начальным состоянием $q_0$, набором принимающих состояний $F$ и
%функцией переходов $\delta$.}{ ответ \glqq да\grqq, если автомат $M$ принимает строку $x$, и ответ \glqq нет\grqq\ --- в противном случае.}
%\begin{algorithmic}
%    \State{$S\gets\epsclos(q_0)$}
%    \State{$c\gets\text{следующий_символ}()$}
%\While{$c\neq\text{eof}$}
%    \State{$S\gets\epsclos(\move(S,c))$}
%    \State{$c\gets\text{следующий_символ}()$}
%\EndWhile
%\If{$S\cap F\neq\emptyset$}
%    \State{выдать \glqq да\grqq}
%\Else
%    \State{выдать \glqq нет\grqq}
%\EndIf
%\end{algorithmic}
%\end{Algorithm}
%
%Приведённые алгоритмы моделирования работы конечных автоматов, по существу, являются алгоритмами, отвечающими на вопрос: принадлежит ли входная строка языку, задаваемому
%конечным автоматом, или нет. Однако для реализации лексического анализа удобнее одновременно с переходами по состояниям совершать действия по построению лексемы
%соответствующего типа. 
%
%\subsection{Построение НКА по регулярному выражению}
%Приведём теперь алгоритм построения по произвольному регулярному выражению недетерминированного конечного автомата, распознающего язык, соответствующий регулярному выражению.
%\begin{Algorithm}{Алгоритм МакНотона--Ямады--Томпсона построения НКА по регулярному выражению.}{регулярное выражение $r$ над алфавитом $\Sigma$.}{НКА $N$, принимающий язык
%$L(r)$.}\label{regexp.to.NDFA}
%
%Начнём с разбора выражения $r$ на составляющие подвыражения. Правила построения НКА состоят из базисных правил для обработки подвыражений без операторов и индуктивных правил
%для построения б\'{о}льших конечных автоматов по автоматам для непосредственных подвыражений данного выражения. Далее действуем в соответствии со следующими правилами.
%
%1) Для каждого подвыражения $\varepsilon$ строим НКА%\newpage
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [bend angle=45,
%    pre/.style={<-,shorten <=1pt,semithick},
%    post/.style={->,shorten >=1pt,semithick},
%    state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=7mm},
%    fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=7mm}]
%    \node (i) {};
%    \node[state] (s) [right=of i] {н}
%    edge [pre] (i);
%    \node[fs] (f) [right=of s] {к}
%    edge [pre] node[auto,swap] {$\varepsilon$} (s) ;
%\end{tikzpicture}}
%\caption{НКА для подвыражения $\varepsilon$.}\label{diagramm.for.NDFA.for.eps}
%\end{figure}
%
%Здесь буквой \glqq н\grqq\  обозначено новое состояние, представляющее собой начальное состояние НКА для подвыражения $\varepsilon$, а буквой \glqq к\grqq\ --- новое состояние,
%являющееся конечным состоянием НКА.
%
%2) Для каждого подвыражения $a$, где $a$ --- символ алфавита $\Sigma$, строим НКА
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [bend angle=45,
%    pre/.style={<-,shorten <=1pt,semithick},
%    post/.style={->,shorten >=1pt,semithick},
%    state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=7mm},
%    fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=7mm}]
%    \node (i) {};
%    \node[state] (s) [right=of i] {н}
%    edge [pre] (i);
%    \node[fs] (f) [right=of s] {к}
%    edge [pre] node[auto,swap] {$a$} (s) ;
%\end{tikzpicture}}
%\caption{НКА для подвыражения $a$, где $a$ --- символ алфавита $\Sigma$.}\label{diagramm.for.NDFA.for.a}
%\end{figure}
%
%Здесь буквой \glqq н\grqq\ обозначено новое состояние, представляющее собой начальное состояние НКА для подвыражения $a$, а буквой \glqq к\grqq\  --- новое состояние,
%являющееся конечным состоянием НКА.
%
%При этом в обоих случаях для каждого подвыражения $\varepsilon$ и каждого подвыражения $a$ строится новый НКА, сколько бы в $r$ ни было экземпляров $\varepsilon$ и  $a$.
%
%3) Предположим теперь, что $N(s)$ и $N(t)$ --- недетерминированные конечные автоматы, построенные по регулярным выражениям $s$ и $t$ соответственно.
%
%а) Пусть $r=st$. В этом случае $N(r)$ строится так, как изображено на рис.\ref{diagramm.for.NDFA.for.concat}.
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=1pt,semithick},
%    post/.style={->,shorten >=1pt,semithick},
%    state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=7mm},
%    fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=7mm}]
%    \matrix[row sep=3mm,column sep=5mm] {
%        \node (sm1) {}; & \node[state] (s1) {н}; & \node (s2) {$N(s)$}; & \node[state] (s3) {}; &  \node (s4) {$N(t)$}; & \node[fs] (s5) {к}; \\
%    };
%    \path (sm1) edge [post] (s1);
%    \draw (s2) ellipse (21mm and 8mm);
%    \draw (s4) ellipse (21mm and 8mm);
%\end{tikzpicture}}
%\vspace{-1mm}
%\caption{НКА для выражения $st$.}\label{diagramm.for.NDFA.for.concat}
%\end{figure}
%
%Начальное состояние автомата $N(s)$ становится начальным состоянием
%автомата $N(r)$, а конечное состояние автомата $N(t)$ --- единственным конечным состоянием автомата $N(r)$. Конечное состояние автомата $N(s)$ и начальное состояние автомата $N(t)$
%склеиваются в одно состояние, со всеми входящими и исходящими переходами обоих состояний.
%
%б) Пусть $r=s|t$. Тогда $N(r)$, НКА для выражения $r$, строится так, как показано на рис.\ref{diagramm.for.NDFA.for.union}. Здесь буквой \glqq н\grqq\ обозначено новое состояние,
%представляющее собой начальное состояние автомата $N(r)$, а буквой \glqq к\grqq\ --- новое состояние, являющееся конечным состоянием НКА. Обратите внимание, что принимающие состояния
%автоматов $N(s)$ и $N(t)$ не являются принимающими состояниями для $N(r)$.
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%pre/.style={<-,shorten <=1pt,semithick},
%post/.style={->,shorten >=1pt,semithick},
%state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=7mm},
%fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=7mm}]
%\matrix[row sep=5mm,column sep=5mm] {
%              &                        & \node[state] (s2) {}; & \node (s23) {$N(s)$}; & \node[state] (s3) {}; &                           \\
%    \node (sm1) {}; & \node[state] (s1) {н}; &                       &                       &                       & \node[fs] (s6) {к};       \\
%              &                        & \node[state] (s4) {}; & \node (s45) {$N(t)$}; & \node[state] (s5) {}; &                           \\
%};
%\path (sm1) edge [post] (s1)
%   (s1)  edge [post] node[pos=0.3,auto] {$\varepsilon$} (s2)
%   (s1)  edge [post] node[pos=0.3,auto] {$\varepsilon$} (s4)
%   (s3)  edge [post] node[pos=0.58,auto] {$\varepsilon$} (s6)
%   (s5)  edge [post] node[auto] {$\varepsilon$} (s6);
%\draw (s23) ellipse (21mm and 8mm);
%\draw (s45) ellipse (21mm and 8mm);
%\end{tikzpicture}}
%\vspace{-1mm}
%\caption{НКА для выражения $s|t$.}\label{diagramm.for.NDFA.for.union}
%\end{figure}
%
%в) Пусть $r=s^*$. Тогда для выражения $r$ НКА $N(r)$ строится так, как изображено на рис.\ref{diagramm.for.NDFA.for.closure}.
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=1pt,semithick},
%    post/.style={->,shorten >=1pt,semithick},
%    state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=7mm},
%    fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=7mm}]
%    \matrix[row sep=5mm,column sep=6mm] {
%        \node (sm1) {}; & \node[state] (s0) {н}; & \node[state] (s1) {}; & \node (s23) {$N(s)$}; & \node[state] (s2) {}; & \node[fs] (s3) {к};       \\
%    };
%    \path (sm1) edge [post]                                                     (s0)
%          (s0)  edge [post]                  node[pos=0.3,auto] {$\varepsilon$} (s1)
%          (s2)  edge [post]                  node[pos=0.6,auto] {$\varepsilon$} (s3)
%          (s2)  edge [post, skip loop=15mm]                                     (s1)
%          (s0)  edge [post, skip loop=-18mm]                                    (s3);
%    \draw (s23) ellipse (21mm and 8mm);
%    \node at (0.5,1.8) {$\varepsilon$};
%    \node at (0.5,-1.5) {$\varepsilon$};
%\end{tikzpicture}}
%\vspace{-1mm}
%\caption{НКА для выражения $s^*$.}\label{diagramm.for.NDFA.for.closure}
%\end{figure}
%
%г) Наконец, пусть $r=(s)$. Тогда $L(r)=L(s)$, так что в качестве $N(r)$ можно использовать $N(s)$.
%\end{Algorithm}
%\begin{Example} Построим с помощью сформулированного алгоритма НКА по выражению $r=(a|b)^*abb$. Как сказано в алгоритме~\ref{regexp.to.NDFA}, для построения НКА, соответствующего регулярному
%выражению, нужно последовательно строить автоматы для подвыражений, а затем данные автоматы склеивать.
%
%Прежде всего рассмотрим подвыражение $r_1=(a|b)$. Согласно подпункту г) пункта 3 алгоритма~\ref{regexp.to.NDFA}, автомат $N(r_1)$ совпадает с автоматом для выражения $r_2=a|b$.
%
%Построим автомат $N(r_2)$. На основании подпункта б) пункта 3 алгоритма~\ref{regexp.to.NDFA}, автомат $N(r_2)$ конструируется из автоматов для подвыражений выражения $r_2$, то есть
%выражения $r_3=a$ и выражения $r_4=b$. В силу пункта 2) алгоритма~\ref{regexp.to.NDFA}, автоматы $N(r_3)$ и $N(r_4)$ имеют вид
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[bend angle=45,
%pre/.style={<-,shorten <=1pt,semithick},
%post/.style={->,shorten >=1pt,semithick},
%state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%    \node (i) {};
%    \node[state] (s) [right=of i] {2}
%    edge [pre] (i);
%    \node[fs] (f) [right=of s] {3}
%    edge [pre] node[auto,swap] {$a$} (s) ;
%\end{tikzpicture}}
%  \caption{НКА для выражения $r_3=a$.}\label{NDFA.diagramm.for.N(r3=a)}
%\end{figure}
%\newpage
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[bend angle=45,
%pre/.style={<-,shorten <=1pt,semithick},
%post/.style={->,shorten >=1pt,semithick},
%state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%    \node (i) {};
%    \node[state] (s) [right=of i] {4}
%    edge [pre] (i);
%    \node[fs] (f) [right=of s] {5}
%    edge [pre] node[auto,swap] {$b$} (s) ;
%\end{tikzpicture}}
%  \caption{НКА для выражения $r_4=b$.}\label{NDFA.diagramm.for.N(r4=b)}
%\end{figure}
%
%Построим теперь автомат $N(r_2)$, пользуясь подпунктом б) пункта 3 алгоритма~\ref{regexp.to.NDFA}:  
%\begin{center}
%%\begin{figure}[!h]
%%\centering
%{\begin{tikzpicture}
%[skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%pre/.style={<-,shorten <=1pt,semithick},
%post/.style={->,shorten >=1pt,semithick},
%state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%\matrix[row sep=4mm,column sep=7mm] {
%                    &                       & \node[state] (s2) {2}; & \node[state] (s3) {3}; &                           \\
%    \node (sm1) {}; & \node[state] (s1) {1};&                        &                        & \node[fs] (s6) {6};       \\
%                    &                       & \node[state] (s4) {4}; & \node[state] (s5) {5}; &                           \\
%};
%\path (sm1) edge [post] (s1)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s2)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s4)
%      (s2)  edge [post] node[auto] {$a$} (s3)
%      (s4)  edge [post] node[auto] {$b$} (s5)
%      (s3)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s5)  edge [post] node[auto] {$\varepsilon$} (s6);
%\end{tikzpicture}}
%%  \caption{НКА для выражения $r_2=a|b$.}\label{NDFA.diagramm.for.N(r2=a|b)}
%%\end{figure}
%\end{center}
%
%Как уже сказано выше, автомат $N(r_1)$ совпадает с автоматом $N(r_2)$.
%
%Рассмотрим подвыражение $r_5=(a|b)^*=r_1^*$. Согласно подпункту в) пункта 3) алгоритма~\ref{regexp.to.NDFA}, автомат $N(r_5)$ выглядит так:
%\begin{center}
%%\begin{figure}[!h]
%%\centering
%{\begin{tikzpicture}
%[skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%pre/.style={<-,shorten <=1pt,semithick},
%post/.style={->,shorten >=1pt,semithick},
%state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%\matrix[row sep=4mm,column sep=7mm] {
%                    &                        &                       & \node[state] (s2) {2}; & \node[state] (s3) {3}; &                          &                       \\
%    \node (sm1) {}; & \node[state] (s0) {0}; & \node[state] (s1) {1};&                        &                        & \node[state] (s6) {6};   & \node[fs] (s7) {7};   \\
%                    &                        &                       & \node[state] (s4) {4}; & \node[state] (s5) {5}; &                          &                       \\
%};
%\path (sm1) edge [post] (s0)
%      (s0)  edge [post] node[auto] {$\varepsilon$} (s1)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s2)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s4)
%      (s2)  edge [post] node[auto] {$a$} (s3)
%      (s4)  edge [post] node[auto] {$b$} (s5)
%      (s3)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s5)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s6)  edge [post] node[auto] {$\varepsilon$} (s7)
%      (s6) edge [post, skip loop=20mm] (s1)
%      (s0) edge [post, skip loop=-21mm] (s7);
%\node at (0.5,2.3) {$\varepsilon$};
%\node at (0.5,-1.8) {$\varepsilon$};
%\end{tikzpicture}}
%%  \caption{НКА для выражения $r_5=(a|b)^*$.}\label{NDFA.diagramm.for.N(r5=(a|b)ast)}
%%\end{figure}
%\end{center}
%
%Построим теперь автомат для выражения $r_6=(a|b)^*a$. Это выражение можно переписать в виде $r_6=r_5r_7$, где $r_7=a$. Для построения $N(r_6)$ нужно построить автомат $N(r_7)$, а затем
%применить подпункт а) пункта 3) алгоритма~\ref{regexp.to.NDFA}: %\newpage
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[bend angle=45,
%pre/.style={<-,shorten <=1pt,semithick},
%post/.style={->,shorten >=1pt,semithick},
%state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%\node (i) {};
%\node[state] (s) [right=of i] {$7'$}
%    edge [pre] (i);
%\node[fs] (f) [right=of s] {8}
%    edge [pre] node[auto,swap] {$a$} (s) ;
%\end{tikzpicture}}
%  \caption{НКА для выражения $r_7=a$.}\label{NDFA.diagramm.for.N(r7=a)}
%\end{figure}
%%\newpage
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
% pre/.style={<-,shorten <=1pt,semithick},
% post/.style={->,shorten >=1pt,semithick},
% state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
% fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%\matrix[row sep=4mm,column sep=7mm] {
%                &                        &                       & \node[state] (s2) {2}; & \node[state] (s3) {3}; &                          &                        &                     \\
%\node (sm1) {}; & \node[state] (s0) {0}; & \node[state] (s1) {1};&                        &                        & \node[state] (s6) {6};   & \node[state] (s7) {7}; & \node[fs] (s8) {8}; \\
%                &                        &                       & \node[state] (s4) {4}; & \node[state] (s5) {5}; &                          &                        &                     \\
%};
%\path (sm1) edge [post] (s0)
%      (s0)  edge [post] node[auto] {$\varepsilon$} (s1)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s2)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s4)
%      (s2)  edge [post] node[auto] {$a$} (s3)
%      (s4)  edge [post] node[auto] {$b$} (s5)
%      (s3)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s5)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s6)  edge [post] node[auto] {$\varepsilon$} (s7)
%      (s7)  edge [post] node[auto] {$a$} (s8)
%      (s6)  edge [post, skip loop=20mm] (s1)
%      (s0)  edge [post, skip loop=-21mm] (s7);
%\node at (-0.2,2.3) {$\varepsilon$};
%\node at (-0.2,-1.8) {$\varepsilon$};
%\end{tikzpicture}}
%  \caption{НКА для выражения $r_6=(a|b)^*a$.}\label{NDFA.diagramm.for.N(r6=(a|b)ast.a)}
%\end{figure}
%
%Рассмотрим теперь подвыражение $r_8=(a|b)^*ab$ выражения $r$. Перепишем выражение $r_8$ в виде $r_8=r_6r_9$, где $r_9=b$. Чтобы построить $N(r_8)$, нужно построить $N(r_9)$, а
%затем отождествить конечное состояние автомата $N(r_6)$ с начальным состоянием автомата $N(r_9)$. В результате получим следующее:
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [bend angle=45,
%    pre/.style={<-,shorten <=1pt,semithick},
%    post/.style={->,shorten >=1pt,semithick},
%    state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%    fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%    \node (i) {};
%    \node[state] (s) [right=of i] {$8'$}
%        edge [pre] (i);
%    \node[fs] (f) [right=of s] {9}
%        edge [pre] node[auto,swap] {$b$} (s) ;
%\end{tikzpicture}}
%  \caption{НКА для выражения $r_9=b$.}\label{NDFA.diagramm.for.N(r9=b)}
%\end{figure}
%%
%%Из подпункта а) пункта 3) алгоритма~\ref{regexp.to.NDFA} следует, что автомат $N(r_8)$ получается, если отождествить состояние $8$ автомата $N(r_6)$ с состоянием $8'$ автомата $N(r_9)$:
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
% pre/.style={<-,shorten <=1pt,semithick},
% post/.style={->,shorten >=1pt,semithick},
% state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
% fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%\matrix[row sep=4mm,column sep=7mm] {
%                &                        &                       & \node[state] (s2) {2}; & \node[state] (s3) {3}; &                          &                        &                        &                        \\
%\node (sm1) {}; & \node[state] (s0) {0}; & \node[state] (s1) {1};&                        &                        & \node[state] (s6) {6};   & \node[state] (s7) {7}; & \node[state] (s8) {8}; & \node[fs] (s9) {9};    \\
%                &                        &                       & \node[state] (s4) {4}; & \node[state] (s5) {5}; &                          &                        &                        &                        \\
%};
%\path (sm1) edge [post] (s0)
%      (s0)  edge [post] node[auto] {$\varepsilon$} (s1)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s2)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s4)
%      (s2)  edge [post] node[auto] {$a$} (s3)
%      (s4)  edge [post] node[auto] {$b$} (s5)
%      (s3)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s5)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s6)  edge [post] node[auto] {$\varepsilon$} (s7)
%      (s7)  edge [post] node[auto] {$a$} (s8)
%      (s6)  edge [post, skip loop=20mm] (s1)
%      (s0)  edge [post, skip loop=-21mm] (s7);
%\node at (-0.8,2.3) {$\varepsilon$};
%\node at (-0.8,-1.8) {$\varepsilon$};
%\path (s8) edge[post] node[auto] {$b$} (s9);
%\end{tikzpicture}}
%  \caption{НКА для выражения $r_8=(a|b)^*ab$.}\label{NDFA.diagramm.for.N(r8=(a|b)ast.ab)}
%\end{figure}
%
%Наконец, рассмотрим само выражение $r=(a|b)^*abb$. Перепишем $r$ в виде $r=r_8r_{10}$, где $r_{10}=b$. Построим автомат для $r_{10}$:
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [bend angle=45,
%    pre/.style={<-,shorten <=1pt,semithick},
%    post/.style={->,shorten >=1pt,semithick},
%    state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=7mm},
%    fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=7mm}]
%    \node (i) {};
%    \node[state] (s) [right=of i] {$9'$}
%        edge [pre] (i);
%    \node[fs] (f) [right=of s] {10}
%        edge [pre] node[auto,swap] {$b$} (s) ;
%\end{tikzpicture}}
%  \caption{НКА для выражения $r_{10}=b$.}\label{NDFA.diagramm.for.N(r10=b)}
%\end{figure}
%Автомат $N(r)$ получится из автоматов $N(r_8)$ и $N(r_{10})$, если отождествить начальное состояние автомата $N(r_{10})$ (состояние $9'$), с конечным состоянием автомата $N(r_8)$
%(состояние 9). После такого отождествления получим следующую диаграмму переходов:
%%\newpage
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
% pre/.style={<-,shorten <=1pt,semithick},
% post/.style={->,shorten >=1pt,semithick},
% state/.style={circle,draw=black,,thick, inner sep=0pt,minimum size=7mm},
% fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=7mm}]
%\matrix[row sep=4mm,column sep=7mm] {
%                &                        &                       & \node[state] (s2) {2}; & \node[state] (s3) {3}; &                          &                        &                        &                        &                       \\
%\node (sm1) {}; & \node[state] (s0) {0}; & \node[state] (s1) {1};&                        &                        & \node[state] (s6) {6};   & \node[state] (s7) {7}; & \node[state] (s8) {8}; & \node[state] (s9) {9}; & \node[fs] (s10) {10}; \\
%                &                        &                       & \node[state] (s4) {4}; & \node[state] (s5) {5}; &                          &                        &                        &                        &                       \\
%};
%\path (sm1) edge [post] (s0)
%      (s0)  edge [post] node[auto] {$\varepsilon$} (s1)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s2)
%      (s1)  edge [post] node[auto] {$\varepsilon$} (s4)
%      (s2)  edge [post] node[auto] {$a$} (s3)
%      (s4)  edge [post] node[auto] {$b$} (s5)
%      (s3)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s5)  edge [post] node[auto] {$\varepsilon$} (s6)
%      (s6)  edge [post] node[auto] {$\varepsilon$} (s7)
%      (s7)  edge [post] node[auto] {$a$} (s8)
%      (s6)  edge [post, skip loop=20mm] (s1)
%      (s0)  edge [post, skip loop=-21mm] (s7);
%\node at (-1.5,2.3) {$\varepsilon$};
%\node at (-1.5,-1.8) {$\varepsilon$};
%\path (s8) edge[post] node[auto] {$b$} (s9)
%      (s9) edge[post] node[auto] {$b$} (s10);
%\end{tikzpicture}}
%  \caption{НКА для выражения $r=(a|b)^*abb$.}\label{NDFA.diagramm.for.N(r=(a|b).ast.abb)}
%\end{figure}
%\end{Example}
%
%\begin{Exercise} Преобразуйте к детерминированному виду следующие недетерминированные конечные автоматы:%Запишите классы символов для следующих множеств:
%{\renewcommand{\theenumi}{\asbuk{enumi}}
%\begin{enumerate}
%    \item автомат
%
%\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%     pre/.style={<-,shorten <=1pt,semithick},
%     post/.style={->,shorten >=1pt,semithick},
%     state/.style={circle,draw=black,,thick, inner sep=0pt,minimum size=6mm},
%     fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%    \matrix[row sep=4mm,column sep=7mm] {
%                         &                        & \node[state] (s1) {1}; & \node[fs] (s2) {2}; \\
%     \node (fictive) {}; & \node[state] (s0) {0}; &                        &                     \\
%                         &                        & \node[state] (s3) {3}; & \node[fs] (s4) {4}; \\
%    };
%    \path (fictive) edge [post]                                     (s0)
%          (s0)      edge [post]         node[auto]  {$\varepsilon$} (s1)
%                    edge [post]         node[auto]  {$\varepsilon$} (s3)
%          (s1)      edge [post]         node[auto]  {$a$}           (s2)
%          (s3)      edge [post]         node[auto]  {$b$}           (s4)
%          (s2)      edge [loop above]   node        {$a$}           ()
%          (s4)      edge [loop above]   node        {$b$}           ();
%\end{tikzpicture}
%
%    \item автомат
%
%\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%     pre/.style={<-,shorten <=1pt,semithick},
%     post/.style={->,shorten >=1pt,semithick},
%     state/.style={circle,draw=black,,thick, inner sep=0pt,minimum size=6mm},
%     fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%    \matrix[row sep=4mm,column sep=7mm] {
%      \node (fictive) {}; & \node[state] (s0) {0}; & \node[state] (s1) {1}; & \node[state] (s2) {2}; & \node[fs] (s3) {3}; \\
%    };
%    \path (fictive) edge [post]                                  (s0)
%          (s0)      edge [post]             node[auto]  {$a$}    (s1)
%                    edge [post, loop below] node[auto]  {$a,b$}  ()
%          (s1)      edge [post]             node[auto]  {$a$}    (s2)
%                    edge [post, loop below] node[auto]  {$a,b$}  ()
%          (s2)      edge [post]             node[auto]  {$b$}    (s3)
%                    edge [post, loop below] node[auto]  {$a,b$}  ()
%          (s2)  edge [post, skip loop=10mm]                      (s0);
%    \node at (-0.1,1.3) {$\varepsilon$};
%\end{tikzpicture}
%
%    \item автомат
%
%\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%     pre/.style={<-,shorten <=1pt,semithick},
%     post/.style={->,shorten >=1pt,semithick},
%     state/.style={circle,draw=black,thick, inner sep=0pt,minimum size=6mm},
%     fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size=6mm}]
%    \matrix[row sep=4mm,column sep=7mm] {
%      \node (fictive) {}; & \node[state] (s0) {0}; & \node[state] (s1) {1}; & \node[state] (s2) {2}; & \node[fs] (s3) {3}; \\
%    };
%    \path (fictive) edge [post]                                             (s0)
%          (s0) edge[post,bend left] node[left,auto]        {$a$}            (s1)
%               edge[post, skip loop=15mm]                                   (s3)
%          (s1) edge[post,bend left] node[right,auto]       {$\varepsilon$}  (s0)
%               edge[post,bend left] node[left,auto]        {$b$}            (s2)
%          (s2) edge[post,bend left] node[right,auto]       {$\varepsilon$}  (s1)
%               edge[post,bend left] node[left,auto]        {$b$}            (s3)
%          (s3) edge[post,bend left] node[right,auto]       {$\varepsilon$}  (s2)
%               edge[post, skip loop=-15mm]                                  (s0);
%        \node at (0.45,1.8) {$\varepsilon$};
%        \node at (0.45,-1.2) {$a$};
%\end{tikzpicture}
%\end{enumerate}
%}
%\end{Exercise}
%
%\begin{Exercise}
%Пользуясь алгоритмами \ref{NDFA.to.DFA} и \ref{regexp.to.NDFA}, постройте детерминированные конечные автоматы по следующим регулярным выражениям:
%{\renewcommand{\theenumi}{\asbuk{enumi}}
%\begin{enumerate}
%    \item $(a|b)^*$;
%    \item $(a^*|b^*)$;
%    \item $((\varepsilon|a)|b^*)^*$;
%    \item $(a|b)^*abb(a|b)^*$.
%\end{enumerate}}
%\end{Exercise}
%
%        \subsection{Построение ДКА по регулярному выражению}
%В данном разделе будет сформулирован алгоритм построения детерминированного конечного автомата непосредственно по регулярному выражению, минуя стадию построения
%недетерминированного автомата.
%
%Прежде чем сформулировать этот алгоритм, рассмотрим роли, которые играют разные состояния автоматов.
%
%Назовём состояние недетерминированного конечного автомата \textbf{важным} если оно имеет исходящий переход не по $\varepsilon$. 
%
%Обратите внимание, что при вычислении
%множества состояний $\epsclos(\move(T,a))$, достижимых из $T$ по входному символу $a$, используются только важные состояния. Таким образом, множество состояний $\move(s,a)$
%--- непусто, только если состояние $s$ --- важное. В процессе построения подмножеств два множества состояний недетерминированного автомата могут отождествляться, то есть
%рассматриваться как единое множество, если они
%
%1) имеют одни и те же важные состояния;
%
%2) либо оба содержат принимающие состояния, либо оба их не содержат.
%
%При построении НКА по регулярному выражению важными состояниями являются только те, которые созданы как начальные для конкретных символов алфавита.
%
%Построенный с помощью алгоритма \ref{regexp.to.NDFA} недетерминированный автомат имеет только одно принимающее состояние. Поскольку это состояние не имеет исходящих
%переходов, то оно важным не является. Приписав к регулярному выражению $r$ справа уникальный ограничитель $\#$\footnote{\small Уникальный в том смысле, что он не встречается
%во входном потоке.}, получим новое регулярное выражение, $(r)\#$, которое назовём \textbf{расширенным регулярным выражением}. Построив затем по расширенному выражению
%конечный автомат, получим, что любое состояние с переходом по символу $\#$ будет принимающим.
%
%Важные состояния НКА соответствуют позициям в регулярном выражении, в которых находятся символы алфавита. Это удобно для представления регулярного выражения его
%\textbf{синтаксическим деревом}, в котором листья соответствуют операндам, а узлы --- операторам. Внутренний узел называется \textbf{с--узлом}, \textbf{или--узлом}, или
%\textbf{звёздочка--узлом}, если он помечен соответственно оператором сцепления ($\circ$), объединения ($|$), или звёздочкой (${}^*$).
%\begin{Example}
%На рис.\ref{Tree.for.(a|b)ast.abb.sharp} изображено синтаксическое дерево для регулярного выражения $(a|b)^*abb\#$. С--узлы обозначены кружками.
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}[level distance=8.5mm]
%\small
%\node{$\circ$}
%    child {node{$\circ$}
%        child{node{$\circ$}
%            child{node{$\nad{n}{\circ}$}
%                child{node{${}^*$}
%                    child{node{$|$}
%                        child{node{$\nad{a}{1}$}}
%                        child{node{$\nad{b}{2}$}}
%                    }
%                }
%                child{node{$\nad{a}{3}$}}
%            }
%            child{node{$\nad{b}{4}$}}
%        }
%        child{node{$\nad{b}{5}$}}
%    }
%    child {node{$\nad{\#}{6}$}}
%;
%\end{tikzpicture}
%}
%\caption{Синтаксическое дерево для регулярного выражения $(a|b)^*abb\#$.}\label{Tree.for.(a|b)ast.abb.sharp}
%\end{figure}
%
%Листья синтаксического дерева помечаются символом $\varepsilon$ или символами алфавита. Каждому листу, не помеченному $\varepsilon$, присваивается целочисленное значение,
%уникальное в пределах дерева. Это значение называется \textbf{позицией} листа, а также позицией его символа. При этом каждый символ алфавита может иметь несколько позиций.
%Например, на рис.\ref{Tree.for.(a|b)ast.abb.sharp} символ $a$ имеет позиции 1 и 3. Иными словами, позиция символа алфавита, входящего в регулярное выражение, --- это позиция
%символа в выражении, полученном из исходного выражения выбрасыванием скобок и операторов. Позиции в синтаксическом дереве соответствуют важным состояниям построенного НКА.
%\end{Example}
%
%Для построения ДКА непосредственно по регулярному выражению нужно определить функции,  $\nullable$, $\firstpos$, $\lastpos$, $\followpos$. Эти функции
%определяются так, как указано ниже, причём для их вычисления используется синтаксическое дерево для расширенного регулярного выражения $(r)\#$.
%\begin{enumerate}
%    \item Значение $\nullable(n)$ для узла $n$ синтаксического дерева равно значению \textbf{истина} тогда и только тогда, когда подвыражение, представленное узлом $n$, содержит в своём
%языке $\varepsilon$. Иными словами, выражение может быть сделано пустой строкой, хотя может содержать в своём языке и непустые строки.
%    \item Значение $\firstpos(n)$ для узла $n$ синтаксического дерева представляет собой множество позиций в поддереве с корнем $n$, соответствующих первому символу как минимум одной
%строки в языке подвыражения с корнем $n$.
%    \item Значение $\lastpos(n)$ есть множество позиций в поддереве с корнем $n$, соответствующих последнему символу хотя бы одной строки в языке подвыражения с корнем $n$.
%    \item Значение $\followpos(p)$ для позиции $p$ представляет собой множество позиций $q$ в синтаксическом дереве в целом, для которых существует строка $x=a_1a_2\dots a_n$ языка
%$L((r)\#)$, такая, что для некоторого $i$ символ $a_i$ соответствует позиции $p$, а символ $a_{i+1}$ --- позиции $q$.
%\end{enumerate}
%
%\begin{Example}Рассмотрим с--узел $n$ на рис.\ref{Tree.for.(a|b)ast.abb.sharp}, соответствующий выражению $(a|b)^*a$. Тогда $\nullable(n)=\textbf{ложь}$, поскольку этот узел порождает все строки из
%$a$ и $b$, оканчивающиеся на $a$, и не может порождать строки $\varepsilon$. С другой стороны, у звёздочка--узла ниже него значение функции $\nullable$ равно значению \textbf{истина}, так
%как наряду со строками из $a$ и $b$ он может порождать и пустую строку, $\varepsilon$.
%
%Покажем теперь, что $\firstpos(n)=\{1,2,3\}$. В с\'{а}мом деле, для любой строки вида $aax$ первая позиция строки соответствует позиции 1 дерева, а первая позиция строки вида $bax$
%соответствует позиции 2. Однако если строка представляет собой $a$, то это $a$ получается из позиции 3.
%
%Далее, $\lastpos(n)=\{3\}$, поскольку неважно, какая именно строка порождается по выражению для узла $n$ --- последняя позиция в строке представляет собой $a$, получающееся из позиции 3.
%
%Наконец, вычислим $\followpos(1)$. Для этого рассмотрим строку вида $\dots ac\dots$, где $c$ --- символ алфавита, причём это $a$ соответствует позиции 1, то есть является одним из
%символов, порождаемых $a$ из подвыражения $(a|b)^*$. За этим $a$ может следовать другое $a$ или $b$ из того же выражения, т.е. в этом случае $c$ получается из позиций 1 и 2. Может также
%оказаться, что $a$ --- последнее в строке, порождённой выражением $(a|b)^*a$. Тогда символ $c$ должен представлять собой $a$, получающееся из позиции 3. Таким образом,
%$\followpos(1)=\{1,2,3\}$.
%\end{Example}
%
%Опишем теперь, как вычислять четыре введённые функции. Что касается функций $\nullable$, $\firstpos$, $\lastpos$, то их можно вычислить рекурсией по высоте синтаксического дерева, применяя
%правила, указанные в табл.\ref{null.first!table}, \ref{last!table}.%\newpage
%\begin{table}[!h]
%  \centering
%  \caption{Правила вычисления функций $\nullable$ и $\firstpos$.}\label{null.first!table}
%\begin{tabular}{|l|p{38mm}|l|}  \hline
%Узел $n$                                & $\nullable(n)$                           & $\firstpos(n)$                          \\  \hline
%$n$ --- лист, помеченный $\varepsilon$  & \textbf{истина}                          & $\emptyset$                             \\  \hline
%$n$ --- лист с позицией $i$             & \textbf{ложь}                            & $\{i\}$                                 \\  \hline
%или--узел $n=c_1|c_2$                   & $\nullable(c_1)\myor$ $\nullable(c_2)$   & $\firstpos(c_1)\cup$ $\firstpos(c_2)$   \\  \hline
%с--узел $n=c_1c_2$                      & $\nullable(c_1)\myand$ $\nullable(c_2)$  &
%{\parbox[t]{50mm}{%
%\textbf{если} $\nullable(c_1)$ \textbf{то}\\
%\phantom{есл}$\firstpos(c_1)\cup\firstpos(c_2)$\\
%\textbf{иначе}\\
%\phantom{есл}$\firstpos(c_1)$\\
%\textbf{всё}%
%}}
%\\  \hline
%звёздочка--узел $n=c^*$                 & \textbf{истина}                          & $\firstpos(c)$                          \\  \hline
%узел $n=c?$                             & \textbf{истина}                          & $\firstpos(c)$                          \\  \hline
%узел $n=c^+$                            & $\nullable(c)$                           & $\firstpos(c)$                          \\  \hline
%\end{tabular}
%\end{table}
%%\newpage
%\begin{table}[!h]
%  \centering
%  \caption{Правила вычисления функции $\lastpos$.}\label{last!table}
%\begin{tabular}{|l|l|}  \hline
%Узел $n$                                & $\lastpos(n)$                             \\  \hline
%$n$ --- лист, помеченный $\varepsilon$  & $\emptyset$                               \\  \hline
%$n$ --- лист с позицией $i$             & $\{i\}$                                   \\  \hline
%или--узел $n=c_1|c_2$                   & $\lastpos(c_1)\cup\lastpos(c_2)$          \\  \hline
%с--узел $n=c_1c_2$                      &
%{\parbox[t]{60mm}{%
%\textbf{если} $\nullable(c_2)$ \textbf{то}\\
%\phantom{есл}$\lastpos(c_1)\cup\lastpos(c_2)$\\
%\textbf{иначе}\\
%\phantom{есл}$\lastpos(c_2)$\\
%\textbf{всё}%
%}}
%\\  \hline
%звёздочка--узел $n=c^*$                 & $\lastpos(c)$                             \\  \hline
%узел $n=c?$                             & $\lastpos(c)$                          \\  \hline
%узел $n=c^+$                            & $\lastpos(c)$                          \\  \hline
%\end{tabular}
%\end{table}
%
%\begin{Example}
%Из всех узлов на рис.\ref{Tree.for.(a|b)ast.abb.sharp} функция $\nullable$ равна \textbf{истина} только для звёздочка--узла. Поясним, почему. Из табл.\ref{null.first!table} видно,
%что ни для какого листа значение функции $\nullable$ не равно \textbf{истина}, поскольку ни один лист не соответствует операнду, равному $\varepsilon$. Или--узел также не может дать
%значения \textbf{истина}, ибо ни один из его дочерних узлов не даёт этого значения. Звёздочка--узел имеет значение \textbf{истина}, так как это свойство любого звёздочка--узла. Наконец, в
%с--узле функция $\nullable$ принимает значение \textbf{ложь}, если таково её значение хотя бы в одном из дочерних узлов.
%На рис.\ref{first.last!fig} показано вычисление функций $\firstpos$ и $\lastpos$ для каждого из узлов (значение $\firstpos(n)$ показано слева от узла $n$, а значение $\lastpos(n)$ ---
%справа).
%
%Каждый лист в качестве значений $\firstpos$ и $\lastpos$, в соответствии с правилом для не--$\varepsilon$--узлов, имеет множество, состоящее только из него самого. Значения функций для
%или--узлов представляют собой объединение значений в дочерних узлах. Что же касается звёздочка--узла, то значения в нём функций $\firstpos$ и $\lastpos$ совпадают со значениями в
%единственном дочернем узле.\newpage
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%[level distance=10mm,
%level 1/.style={sibling distance=25mm},
%level 2/.style={sibling distance=25mm},
%level 3/.style={sibling distance=25mm},
%level 4/.style={sibling distance=25mm}]
%\small
%\node{$\{1,2,3\}\,\circ\,\{6\}$}
%    child {node{$\{1,2,3\}\,\circ\,\{5\}$}
%        child{node{$\{1,2,3\}\,\circ\,\{4\}$}
%            child{node{$\{1,2,3\}\,\circ\,\{3\}$}
%                child{node{$\{1,2\}\,{}^*\,\{1,2\}$}
%                    child{node{$\{1,2\}\,|\,\{1,2\}$}
%                        child{node{$\{1\}\,a\,\{1\}$}}
%                        child{node{$\{2\}\,b\,\{2\}$}}
%                    }
%                }
%                child{node{$\{3\}\,a\,\{3\}$}}
%            }
%            child{node{$\{4\}\,b\,\{4\}$}}
%        }
%        child{node{$\{5\}\,b\,\{5\}$}}
%    }
%    child {node{$\{6\}\,\#\,\{6\}$}}
%;
%\end{tikzpicture}
%}
%\caption{Значения функций $\firstpos$ и $\lastpos$ в узлах синтаксического дерева для регулярного выражения $(a|b)^*abb\#$.}\label{first.last!fig}
%\end{figure}
%
%Перейдём теперь к с\'{а}мому нижнему с--узлу, обозначив его $n$. Вычисление $\firstpos(n)$ начнём с проверки значения $\nullable$ в левом дочернем узле. В нашем случае оно равно
%\textbf{истина}. Поэтому $\firstpos$ в узле $n$ представляет собой объединение значений $\firstpos$ в дочерних узлах, т.е. равно $\{1,2\}\cup\{3\}\equiv\{1,2,3\}$.
%\end{Example}
%
%Перейдём теперь к вычислению функции $\followpos$. Вычисляется эта функция по следующим двум правилам:
%\begin{enumerate}
%    \item если $n$ --- с--узел с левым потомком $c_1$ и правым потомком $c_2$, то для каждой из позиций $i$ из $\lastpos(c_1)$ все позиции из $\firstpos(c_2)$ содержатся в
%$\followpos(i)$;
%    \item если $n$ --- звёздочка--узел и $i$ --- позиция из $\lastpos(n)$, то все позиции из $\firstpos(n)$ содержатся в $\followpos(i)$.
%\end{enumerate}
%
%\begin{Example} Вычислим теперь для узлов дерева, изображённого на рис.\ref{Tree.for.(a|b)ast.abb.sharp}, значение функции $\followpos$. При этом, поскольку значения функций
%$\firstpos$ и $\lastpos$ для каждого узла изображены на рис.\ref{first.last!fig}, то для вычислений будем использовать рис.\ref{first.last!fig}. Согласно первому правилу, нужно просмотреть
%каждый с--узел и поместить каждую позицию из $\firstpos$ его правого дочернего узла в $\followpos$ для каждой позиции из $\lastpos$ его левого дочернего узла. Для с\'{а}мого нижнего
%с--узла на рис.\ref{first.last!fig} это означает, что позиция 3 находится как $\followpos(1)$, так и в $\followpos(2)$. Рассмотрев следующий, находящийся выше, с--узел, получим, что
%позиция 4 содержится в $\followpos(3)$. Что же касается оставшихся двух с--узлов, то 5 входит в $\followpos(4)$, а 6 --- в $\followpos(5)$.
%
%Применим теперь к звёздочка--узлу правило 2. Это правило гласит, что позиции 1 и 2 находятся как в $\followpos(1)$, так и в $\followpos(2)$, ибо для этого узла и $\firstpos$, и
%$\lastpos$ равны $\{1,2\}$. Результаты всех этих вычислений собраны в табл.\ref{followpos!table}
%\begin{table}[!h]
%  \centering
%  \caption{Значения функции $\followpos$.}\label{followpos!table}
%  \vspace{1mm}
%\begin{tabular}{|c|l|}  \hline
%Узел $n$    & $\followpos(n)$   \\  \hline
%1           & $\{1,2,3\}$       \\  \hline
%2           & $\{1,2,3\}$       \\  \hline
%3           & $\{4\}$           \\  \hline
%4           & $\{5\}$           \\  \hline
%5           & $\{6\}$           \\  \hline
%6           & $\emptyset$       \\  \hline
%\end{tabular}
%\end{table}
%\end{Example}
%
%Сформулируем, наконец, алгоритм построения ДКА непосредственно по регулярному выражению.
%\begin{Algorithm}{Построение ДКА по регулярному выражению.}{регулярное выражение $r$ над алфавитом $\Sigma$.}{ДКА $D$, принимающий язык $L(r)$.}\label{regexp.to.DFA}
%\begin{enumerate}
%    \item Построить синтаксическое дерево $T$ по расширенному регулярному выражению $(r)\#$.
%    \item Вычислить для дерева $T$ функции $\nullable$, $\firstpos$, $\lastpos$, и $\followpos$.
%    \item Построить $D_{\text{сост}}$ --- множество состояний детерминированного конечного автомата $D$, и функцию $D_{\text{п}}$ --- функцию переходов этого автомата, выполнив приводимую
%ниже процедуру. Состояния автомата $D$ представляют собой множества позиций узлов дерева $T$. Изначально ни одно состояние \glqq непомечено\grqq; состояние становится
%\glqq помеченным\grqq\  непосредственно перед тем, как рассматриваются его переходы. Начальным состоянием автомата $D$ является $\firstpos(n_0)$, где $n_0$ --- корень дерева $T$.
%Принимающими состояниями являются состояния, содержащие позицию для символа--ограничителя $\#$.
%\end{enumerate}
%
%\begin{algorithmic}
%\Procedure{состояния_и_переходы}{}
%    \State{$D_{\text{сост}}\gets\{\firstpos(n_0)\}$}
%    \Comment{$n_0$ --- корень дерева разбора для $(r)\#$; единственное имеющееся}\\
%    \Comment{состояние является начальным и непомечено}%\\
%    \While{в $D_{\text{сост}}$ имеется непомеченное состояние $S$}
%        \State{пометить $S$}
%        \ForAll{входных символов $a$}
%            \State{$U\gets\bigcup\limits_{\substack{p\in S,\\ p \text{ отвечает } a}}\!\!\!\!\followpos(p)$}
%            \If{$U\notin D_{\text{сост}}$}
%                \State{добавить $U$ в $D_{\text{сост}}$ как непомеченное}
%            \EndIf
%            \State{положить $D_{\text{п}}(S,a)=U$}
%        \EndFor
%    \EndWhile
%\EndProcedure
%\end{algorithmic}
%\end{Algorithm}
%
%\begin{Example}
%Построим ДКА по регулярному выражению $r=(a|b)^*abb$. Синтаксическое дерево для $(r)\#$ показано на рис.\ref{Tree.for.(a|b)ast.abb.sharp}. Мы уже знаем, что функция $\nullable$ имеет
%значение \textbf{истина} только в звёздочка--узле. Значения функций $\firstpos$ и $\lastpos$ показаны на рис.\ref{first.last!fig}, а значения функции $\followpos$ --- в
%табл.\ref{followpos!table}.
%
%Значение функции $\firstpos$ в корне равно $\{1,2,3\}$, так что это множество является начальным состоянием автомата $\mathcal{D}$. Обозначим это состояние $A$. Мы должны вычислить
%$\mathcal{D}_{\text{п}}(A,a)$ и $\mathcal{D}_{\text{п}}(A,b)$. Среди позиций из множества $A$ символу $a$ соответствуют позиции 1 и 3, а символу $b$ --- позиция 2. Таким образом,
%$\mathcal{D}_{\text{п}}(A,a)=\followpos(1)\cup\followpos(3)=\{1,2,3,4\}$, а $\mathcal{D}_{\text{п}}(A,b)=\followpos(2)=\{1,2,3\}$. Последнее состояние представляет собой состояние $A$,
%так что в $\mathcal{D}_{\text{сост}}$ его добавлять не нужно. Состояние же $B\equiv\{1,2,3,4\}$ является новым, так что добавляем его в $\mathcal{D}_{\text{сост}}$ и вычисляем его переходы,
%$\mathcal{D}_{\text{п}}(B,a)$ и $\mathcal{D}_{\text{п}}(B,b)$:
%\begin{align*}
%\mathcal{D}_{\text{п}}(B,a) &=\bigcup\limits_{\substack{p\in B,\\ p \text{ отвечает } a}}\!\!\!\!\followpos(p)=\followpos(1)\cup\followpos(3)=B;\\
%\mathcal{D}_{\text{п}}(B,b) &=\bigcup\limits_{\substack{p\in B,\\ p \text{ отвечает } b}}\!\!\!\!\followpos(p)=\followpos(2)\cup\followpos(4)=\{1,2,3\}\cup\{5\}=\{1,2,3,5\}\equiv C.
%\end{align*}
%Вычислим переходы для состояния $C$:
%\begin{align*}
%\mathcal{D}_{\text{п}}(C,a) &=\bigcup\limits_{\substack{p\in C,\\ p \text{ отвечает } a}}\!\!\!\!\followpos(p)=\followpos(1)\cup\followpos(3)=B;\\
%\mathcal{D}_{\text{п}}(C,b) &=\bigcup\limits_{\substack{p\in C,\\ p \text{ отвечает } b}}\!\!\!\!\followpos(p)=\followpos(2)\cup\followpos(5)=\{1,2,3\}\cup\{6\}=\{1,2,3,6\}\equiv D.
%\end{align*}
%Состоянием, содержащим позицию, соответствующую символу $\#$, является лишь состояние $D$. Следовательно, это состояние будет конечным.
%
%Наконец, вычислим переходы для состояния $D$:
%\begin{align*}
%\mathcal{D}_{\text{п}}(D,a)  &=\bigcup\limits_{\substack{p\in D,\\ p \text{ отвечает } a}}\!\!\!\!\followpos(p)=\followpos(1)\cup\followpos(3)=B;\\
%\mathcal{D}_{\text{п}}(D,b)  &=\bigcup\limits_{\substack{p\in D,\\ p \text{ отвечает } b}}\!\!\!\!\followpos(p)=\followpos(2)\cup\followpos(6)=\{1,2,3\}=A.
%\end{align*}
%Соответствующая диаграмма переходов изображена на приводимом ниже рисунке. %\newpage
%
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%     pre/.style={<-,shorten <=1pt,semithick},
%     post/.style={->,shorten >=1pt,semithick},
%     state/.style={circle,draw=black,thick, inner sep=0pt,minimum size =11mm},
%     fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size =11mm}]
%    \matrix[row sep=8mm,column sep=10mm] {
%                            &                           & \node[fs] (s1236) {1236};   &                            \\
%                            &                           &                             &                            \\
%                            &                           &                             &                            \\
%        \node (fictive) {}; & \node[state] (s123){123}; & \node[state] (s1234){1234}; & \node[state] (s1235){1235};\\
%    };
%    \path (fictive) edge [post]                                        (s123)
%          (s123)    edge [post]            node[auto]            {$a$} (s1234)
%                    edge [post,loop below] node[auto]            {$b$} ()
%          (s1235)   edge [post]            node[auto,swap]       {$b$} (s1236)
%                    edge [pre,bend left]   node[left,auto]       {$b$} (s1234)
%                    edge [post,bend right] node[right,auto,swap] {$a$} (s1234)
%          (s1236)   edge [post]            node[auto]            {$a$} (s1234)
%                    edge [post]            node[auto,swap]       {$b$} (s123)
%          (s1234)   edge [post,loop below] node[auto]            {$a$} ();
%\end{tikzpicture}}
%  \caption{Ещё один ДКА для регулярного выражения $r=(a|b)^*abb$.}\label{Another.DFA.for.(a|b)ast.abb}
%\end{figure}
%\end{Example}
%
%        \subsection{Минимизация детерминированных конечных автоматов}
%Один и тот же язык могут распознавать разные ДКА. В качестве примера можно привести автоматы, диаграммы переходов которых изображены на рисунках
%\ref{diagramm.for.DFA.for.(a|b)ast.abb} и \ref{Another.DFA.for.(a|b)ast.abb}. Такие автоматы могут иметь не только разные имена состояний, но и разное количество состояний.
%При реализации лексического анализатора с помощью ДКА, вообще говоря, лучше иметь конечный автомат с минимально возможным количеством состояний. Связано это с тем, что для
%каждого состояния нужны записи в таблице, описывающей лексический анализатор. При этом имена состояний значения не имеют.
%
%Будем говорить, что два автомата \textbf{одинаковы с точностью до имён состояний}, если один из них можно получить из другого простым переименованием состояний. Однако между
%состояниями автоматов, изображённых на рис.\ref{diagramm.for.DFA.for.(a|b)ast.abb} и \ref{Another.DFA.for.(a|b)ast.abb} есть более тесная связь. А именно, состояния $A$ и $C$
%автомата на рис.\ref{diagramm.for.DFA.for.(a|b)ast.abb} на самом деле эквивалентны, в том смысле, что ни одно из них не является принимающим, и любой входной символ приводит
%к одинаковым переходам --- в состояние $B$ для входного символа $a$ и в состояние $C$ для входного символа $b$. Если мы теперь склеим состояния $A$ и $C$ в одно состояние и
%обозначим получившееся состояние $AC$, то получим следующую диаграмму переходов:
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%     pre/.style={<-,shorten <=1pt,semithick},
%     post/.style={->,shorten >=1pt,semithick},
%     state/.style={circle,draw=black,thick, inner sep=0pt,minimum size =6.5mm},
%     fs/.style={double,circle,draw=black,thick, inner sep=0pt,minimum size =6.5mm}]
%    \matrix[row sep=4mm,column sep=15mm] {
%                            &                            & \node[fs] (s1236) {$E$};   &                            \\
%                            &                            &                            &                            \\
%                            &                            &                            &                            \\
%        \node (fictive) {}; & \node[state] (s123){$AC$}; & \node[state] (s1234){$B$}; & \node[state] (s1235){$D$}; \\
%    };
%    \path (fictive) edge [post]                                        (s123)
%          (s123)    edge [post]            node[auto]            {$a$} (s1234)
%                    edge [post,loop below] node[auto]            {$b$} ()
%          (s1235)   edge [post]            node[auto,swap]       {$b$} (s1236)
%                    edge [pre,bend left]   node[left,auto]       {$b$} (s1234)
%                    edge [post,bend right] node[right,auto,swap] {$a$} (s1234)
%          (s1236)   edge [post]            node[auto]            {$a$} (s1234)
%                    edge [post]            node[auto,swap]       {$b$} (s123)
%          (s1234)   edge [post,loop below] node[auto]            {$a$} ();
%\end{tikzpicture}}
%\caption{Минимизированный ДКА для регулярного выражения $(a|b)^*abb$}\label{diagramm.for.minimized.DFA.for.(a|b)ast.abb}
%\end{figure}
%
%Иными словами, состояния $A$ и $C$ ведут себя так же, как и состояние 123 на рис.\ref{Another.DFA.for.(a|b)ast.abb}; состояние $B$ --- состояние 1234; состояние $D$ --- как
%состояние 1235; а состояние $E$ --- как состояние 1236.
%
%Оказывается, что для любого регулярного языка всегда существует единственный (с точностью до имён состояний) ДКА, распознающий этот язык и имеющий минимальное количество
%состояний. Более того, этот ДКА с минимальным количеством состояний можно построить по любому ДКА для того же самого языка, склеив эквивалентные сос\-тояния. Для языка
%$L((a|b)^*abb)$ ДКА с минимальным количеством сос\-тояний показан на рис.\ref{Another.DFA.for.(a|b)ast.abb}, и этот автомат можно получить из ДКА, изображённого на
%рис.\ref{diagramm.for.DFA.for.(a|b)ast.abb}, сгруппировав состояниям следующим образом: $\{A,C\}\{B\}\{D\}\{E\}$.
%
%Чтобы понять, как работает алгоритм преобразования ДКА в эквивалентный ДКА с минимальным количеством состояний, рассмотрим, как входные строки отличают одно состояние от
%другого. Будем говорить, что строка $x$ \textbf{отличает} состояние $s$ от состояния $t$, если ровно одно из состояний, достижимых из $s$ и $t$, по пути с меткой $x$
%является принимающим, а другое --- нет. Будем говорить, что состояние $s$ \textbf{отличимо} от состояния $t$, если найдётся строка, которая их отличает.
%\begin{Example}
%Пустая строка отличает любое принимающее состояние от непринимающего. На рис.\ref{diagramm.for.DFA.for.(a|b)ast.abb} строка $bb$ отличает состояние $A$ от состояния $B$, так
%как эта строка приводит из $A$ в непринимающее состояние $C$, а из $B$ --- в принимающее состояние $E$.
%\end{Example}
%
%Алгоритм, минимизирующий количество состояний, работает путём разбиения множества состояний ДКА на группы неотличимых состояний. Каждая такая группа представляет собой одно
%состояние ДКА с минимальным количеством состояний. Алгоритм работает с разбиением, группы которого представляют собой множества состояний, отличие которых друг от друга пока
%не выявлено. Если никакую группу разбиения нельзя разделить на меньшие группы, то получен ДКА с минимальным количеством состояний.
%
%Первоначально разбиение состоит из двух групп состояний: принимающие и непринимающие. Основной шаг состоит в том, чтобы взять некоторую группу состояний
%$A\equiv\{s_1,\dots,s_k\}$ и некоторый входной символ $a$, и посмотреть, можно ли $a$ использовать для отличения некоторых состояний в группе $A$. Делается это так:
%рассматриваем переходы из каждого из состояний $s_1,\dots,s_k$ по символу $a$, и если состояния переходят в две или более группы текущего разбиения, то группу $A$ разделяем
%так, чтобы состояния $s_i$ и $s_j$ оказывались в одной группе тогда и только тогда, когда они переходят в одну и ту же группу по данному входному символу $a$. Этот процесс
%продолжается до тех пор, пока не окажется ни одной группы, которую можно было бы разделить хотя бы одним входным символом. Данная идея реализована в следующем алгоритме.
%\begin{Algorithm}{Минимизация количества состояний ДКА.}{ДКА $D$ с множеством состояний $Q$, входным алфавитом $\Sigma$, начальным состоянием $q_0$ и множеством принимающих
%состояний $F$.}{ДКА $D'$, принимающий тот же язык, что и автомат $D$, и имеющий наименьшее возможное количество состояний.}\label{DFA.Minimization}
%\begin{enumerate}
%    \item Начинаем с разбиения $\Pi$ множества $Q$ на две группы, $F$ и $Q\setminus F$, состоящие, соответственно, из принимающих и непринимающих состояний автомата $D$.
%    \item Применяем приводимую ниже процедуру для построения нового разбиения, $\Pi_{\text{нов}}$.
%\begin{algorithmic}
%\Procedure{новое_разбиение}{$(\Pi)$}%\textbf{\textbf{множество из множество из }$Q$}
%    \State{$\Pi_{\text{нов}}\gets\Pi$}
%    \ForAll{$G\in\Pi_{\text{нов}}$}
%\State{\parbox[t]{120mm}{Разбиваем $G$ на подгруппы так, чтобы два состояния, $s$ и $t$, находились в одной подгруппе тогда и только тогда, когда для каждого входного
%символа $a$ состояния $s$ и $t$ имеют переходы по этому символу в состояния, принадлежащие одной и той же подгруппе группы $G$. При этом для разных символов подгруппы могут
%и отличаться. Заменяем в $\Pi_{\text{нов}}$ подгруппу $G$ на набор пос\-троенных подгрупп.}}
%%\State{\parbox[t]{120mm}{}}
%    \EndFor
%\EndProcedure
%\end{algorithmic}
%    \item Если $\Pi_{\text{нов}}=\Pi$, то полагаем $\Pi_{\text{оконч}}=\Pi$ и переходим к шагу 4. В противном случае переходим к шагу 2, заменяя $\Pi$ на $\Pi_{\text{нов}}$.
%    \item Выбираем из каждой группы разбиения $\Pi_{\text{оконч}}$ по одному состоянию в качестве \textbf{представителя} этой группы. Представители будут состояниями ДКА с
%минимальным количеством состояний, автомата $D'$. Остальные компоненты автомата $D'$ строятся следующим образом.
%{\renewcommand{\theenumii}{\asbuk{enumii}}
%\renewcommand{\labelenumii}{\theenumii)}
%\begin{enumerate}
%    \item Начальное состояние автомата $D'$ --- представитель группы, содержащей начальное состояние автомата $D$.
%    \item Принимающими состояниями автомата $D'$ являются представители групп, содержащих принимающие состояния автомата $D$. Заметим, что каждая группа содержит либо только
%принимающие состояния, либо только непринимающие, поскольку мы начинали работу с отделения этих классов состояний друг от друга, а при вычислении нового разбиения строятся
%группы состояний, являющиеся подгруппами уже построенных групп.
%    \item Пусть $s$ --- представитель некоторой группы $G$ в $\Pi_{\text{оконч}}$, и пусть переход по входному символу $a$ в автомате $D$ ведёт из состояния $s$ в состояние
%$t$. Пусть $r$ --- представитель группы $H$, в которую входит состояние $t$. Тогда в $D'$ имеется переход из $s$ в $r$ по входному символу $a$. Заметим, что в $D$ каждое
%состояние группы $G$ должно при входном символе $a$ переходить в некоторое состояние группы $H$, ибо иначе группа $G$ была бы разделена.
%\end{enumerate}}
%\end{enumerate}
%\end{Algorithm}
%
%\begin{Example}
%Снова вернёмся к ДКА на рис.\ref{diagramm.for.DFA.for.(a|b)ast.abb}. Начальное разбиение состоит из двух групп, $\{A,B,C,D\}\{E\}$, состоящих, соответственно, из
%непринимающих и принимающего состояния. Для построения $\Pi_{\text{нов}}$ рассмотрим обе группы и входные символы $a$ и $b$. Группу $\{E\}$ разделить нельзя, так как она
%состоит из одного состояния. Поэтому в $\Pi_{\text{нов}}$ эта группа остаётся неизменной.
%
%Группу $\{A,B,C,D\}$ разделить можно, так что нужно рассмотреть воздействие на неё каждого входного символа. При входном символе $a$ все состояния группы переходят в
%состояние $B$, так что отличить эти состояния при помощи строки, начинающейся с $a$, невозможно. При входном символе $b$ состояния $A$, $B$, и $C$ переходят в состояния,
%являющиеся членами группы $\{A,B,C,D\}$, тогда как состояние $D$ переходит в $E$, которое является членом другой группы. Таким образом, в $\Pi_{\text{нов}}$ группа
%$\{A,B,C,D\}$ разбивается на $\{A,B,C\}\{D\}$, и $\Pi_{\text{нов}}$ на данной итерации представляет собой $\{A,B,C\}\{D\}\{E\}$.
%
%На следующей итерации группу $\{A,B,C\}$ можно разбить на группы $\{A,C\}\{B\}$, поскольку и $A$, и $C$ при входном символе $b$ переходят в состояния группы $\{A,B,C\}$, а
%состояние $B$ по этому входному символу переходит в состояние из другой группы, $\{D\}$. Таким образом, после второй итерации $\Pi_{\text{нов}}=\{A,C\}\{B\}\{D\}\{E\}$. На
%следующей итерации единственную оставшуюся группу с более чем одним состоянием разделить не получится, ибо и $A$, и $C$ переходят в одно и то же состояние (а, значит, и в
%одну и ту же группу) по любому входному символу. Как следствие, $\Pi_{\text{оконч}}=\{A,C\}\{B\}\{D\}\{E\}$.
%
%Построим теперь по получившемуся разбиению компоненты ДКА с минимальным количеством состояний. Он имеет четыре состояния, соответствующие четырём группам разбиения
%$\Pi_{\text{оконч}}$. В качестве представителей групп выбираем состояния $A$, $B$, $D$, и $E$. Начальным состоянием является состояние $A$, а единственным принимающим
%состоянием --- состояние $E$. В табл.\ref{Minimal.DFA!table} показана функция переходов этого ДКА.
%\begin{table}[!h]
%  \centering
%  \caption{Таблица переходов ДКА с минимальным количеством состояний.}\label{Minimal.DFA!table}
%  \vspace{1mm}
%\begin{tabular}{|c|c|c|}  \hline
%      & $a$ & $b$ \\  \hline
%$A$   & $B$ & $A$ \\  \hline
%$B$   & $B$ & $D$ \\  \hline
%$D$   & $B$ & $E$ \\  \hline
%$E$   & $B$ & $A$ \\  \hline
%\end{tabular}
%\end{table}
%\end{Example}
%
%\begin{Exercise}
%Пользуясь алгоритмом \ref{regexp.to.DFA}, постройте ДКА по следующим регулярным выражениям:
%{\renewcommand{\theenumi}{\asbuk{enumi}}
%\begin{enumerate}
%    \item $(a|b)^*$;
%    \item $(a^*|b^*)^*$;
%    \item $((\varepsilon|a)b^*)^*$;
%    \item $(a|b)^*abb(a|b)^*$.
%\end{enumerate}
%}
%\end{Exercise}
%
%\begin{Exercise}
%Можно доказать эквивалентность двух регулярных выражений, если показать, что их ДКА с минимальным количеством состояний одинаковы с точностью до имён состояний. Покажите
%таким образом, что регулярные выражения $(a|b)^*$, $(a^*|b^*)^*$, и $((\varepsilon|a)b^*)^*$ --- эквивалентны.
%\end{Exercise}
%
%\begin{Exercise}
%Пользуясь алгоритмами \ref{regexp.to.DFA} и \ref{DFA.Minimization}, постройте ДКА с минимальным количеством состояний по следующим регулярным выражениям:
%{\renewcommand{\theenumi}{\asbuk{enumi}}
%\begin{enumerate}
%    \item $(a|b)^*a(a|b)$;
%    \item $(a|b)^*a(a|b)(a|b)$;
%    \item $(a|b)^*a(a|b)(a|b)(a|b)$;
%    \item $(a|b)^*a(a|b)(a|b)(a|b)(a|b)$.
%\end{enumerate}
%}
%\end{Exercise}
%
%    \section{Нерегулярные языки и лемма о разрастании}
%В данном разделе доказывается, что не все языки являются регулярными. А именно, мы докажем, что регулярным не является язык $\{a^nb^n:n>0\}$. Для этого потребуется следующая
%лемма, говорящая о том, чем \glqq внутренне устройство\grqq\ регулярных языков отличается от устройства языков нерегулярных.
%\begin{Lemma} (О разрастании (или о накачке) для регулярных языков.) Пусть $L$ --- некоторый регулярный язык с бесконечным количеством элементов. Тогда существует такое
%число $N$, что любая строка языка $L$, длина которой не менее $N$, может быть представлена в виде $xyz$, где
%
%1) подстрока $y$ --- непуста ($y\neq\varepsilon$);
%
%2) $|xy|\leqslant N$;
%
%3) строки $xz,xyz,xyyz,\dots,xy^nz,\dots,$ принадлежат языку $L$.
%\end{Lemma}
%
%Покажем теперь, что язык $L=\{a^nb^n:n>0\}$ --- нерегулярен. Предположим, что это не так. Тогда должна выполняться лемма о разрастании. Поскольку эта лемма должна выполняться для любой строки, длина которой не меньше $N$ (которое мы не знаем), то лемма должна выполняться и для строки
%\begin{gather*}
%\xi=\underbrace{a\dots a}_{N}\underbrace{b\dots b}_{N}.
%\end{gather*}
%Ясно, что $|\xi|=2N$. По лемме строку $\xi$ можно записать в виде $\xi=xyz$, где $|xy|\leqslant N$, $y\neq\varepsilon$. Так как первые $N$ символов строки $\xi$ --- это
%символы $a$, то подстрока $y$ может состоять лишь из символов $a$. Но любая попытка \glqq накачки\grqq\ приведёт к тому, что количество символов $a$ увеличится, а количество
%символов $b$ остаётся неизменным. Иными словами, \glqq накачанная\grqq\ строка языка $L$ не принадлежит. Полученное противоречие доказывает нерегулярность языка $L$.
%
%\chapter{Структура обрабатываемых файлов и порождаемый программный код}
%	\section{Структура файла с описанием лексического анализатора}
%	
%	
%	
%Опишем структуру, которую должен иметь файл с описанием лексического анализатора.
%
%Структура эта должна быть такой:
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%scaner_name} \textcolor{Green}{\textit{имя_сканера}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%codes_type} \textcolor{Green}{\textit{имя_типа_кодов_лексем}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%ident_name} \textcolor{Green}{\textit{имя_идентификатора}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%token_fields} \textcolor{Green}{\textit{добавляемые_поля_лексемы}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%class_members} \textcolor{Green}{\textit{добавляемые_члены_класса}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%newline_is_lexem}\texttt{\textcolor{Green}{]}} 
%
%\noindent%
%\textbf{\%codes}
%
%\textcolor{Green}{\textit{имя_кода_лексемы}}\texttt{\textcolor{Green}{\{}},\textcolor{Green}{\textit{имя_кода_лексемы}}\texttt{\textcolor{Green}{\}}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%header_additions}  \textcolor{Green}{\textit{дополнения_для_заголовочного_файла}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%impl_additions}  \textcolor{Green}{\textit{дополнения_для_файла_реализации}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%lexem_info_name}  \textcolor{Green}{\textit{имя_типа_со_сведениями_о_лексеме}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%keywords} \texttt{\textcolor{Green}{[}}\textcolor{Green}{\textit{действия_по_завершении}}:\texttt{\textcolor{Green}{]}}
%
%\textcolor{Green}{\textit{строка_ключевого_слова}} : \textcolor{Green}{\textit{код_ключевого_слова}}
%
%\texttt{\textcolor{Green}{\{}},\textcolor{Green}{\textit{строка_ключевого_слова}} : \textcolor{Green}{\textit{код_ключевого_слова}}\texttt{\textcolor{Green}{\}}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%idents}
%
%\{\textcolor{Green}{\textit{описание_начала_идентификатора}}\}
%
%\{\textcolor{Green}{\textit{описание_тела_идентификатора}}\}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%delimiters} \texttt{\textcolor{Green}{[}}\textcolor{Green}{\textit{действия_по_завершении}}:\texttt{\textcolor{Green}{]}}
%
%\textcolor{Green}{\textit{строка_разделителя}} : \textcolor{Green}{\textit{код_разделителя}}
%
%\texttt{\textcolor{Green}{\{}},\textcolor{Green}{\textit{строка_разделителя}} : \textcolor{Green}{\textit{код_разделителя}}\texttt{\textcolor{Green}{\}}}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%numbers} \texttt{\textcolor{Green}{[}}\textcolor{Green}{\textit{действия_при_инициализации}}\texttt{\textcolor{Green}{]}}:\texttt{\textcolor{Green}{[}}\textcolor{Green}{\textit{действия_по_завершении}}:\texttt{\textcolor{Green}{]}} 
%
%\texttt{\textcolor{Green}{\{}}\textbf{\%action} \textcolor{Green}{\textit{имя_действия}} \textcolor{Green}{\textit{определение_действия}} \texttt{\textcolor{Green}{\}}}
%\{\textcolor{Green}{\textit{выражение}}\}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%strings} \texttt{\textcolor{Green}{[}}\textcolor{Green}{\textit{действия_при_инициализации}}\texttt{\textcolor{Green}{]}}:\texttt{\textcolor{Green}{[}}\textcolor{Green}{\textit{действия_по_завершении}}:\texttt{\textcolor{Green}{]}} 
%
%\texttt{\textcolor{Green}{\{}}\textbf{\%action} \textcolor{Green}{\textit{имя_действия}} \textcolor{Green}{\textit{определение_действия}} \texttt{\textcolor{Green}{\}}}
%\{\textcolor{Green}{\textit{выражение}}\}\texttt{\textcolor{Green}{]}}
%
%\noindent%
%\texttt{\textcolor{Green}{[}}\textbf{\%comments}
%
%\texttt{\textcolor{Green}{[}}\textbf{\%single_lined} \textcolor{Green}{\textit{начало_однострочного_комментария}}\texttt{\textcolor{Green}{]}}
%
%\texttt{\textcolor{Green}{[}}\textbf{\%multilined} \texttt{\textcolor{Green}{[}}%
%\textbf{\%nested}\texttt{\textcolor{Green}{]}}
%
%\textcolor{Green}{\textit{начало_многострочного_комментария}} :
%\textcolor{Green}{\textit{конец_многострочного_комментария}}\texttt{\textcolor{Green}{]}}%
%\textcolor{Green}{\texttt{]}}
%
%Прежде чем пояснить смысл каждой из приведённых только что конструкций, условимся, что
%\begin{enumerate}
%\item всё, заключённое в квадратные скобки зелёного цвета  (\texttt{\textcolor{Green}{[}}\dots\texttt{\textcolor{Green}{]}}) является необязательным;
%\item то, что заключено в фигурные скобки зелёного цвета  (\texttt{\textcolor{Green}{\{}}\dots\texttt{\textcolor{Green}{\}}}), может повторяться любое число раз, в том числе и ни разу. 
%\end{enumerate}
%
%Прежде чем перейти к пояснению этой структуры, отметим, что под строковым литералом Мяуки (далее просто строковым литералом) будет пониматься любая (в том числе пустая) цепочка
%символов, заключённая в двойные кавычки. Если в этой последовательности нужно указать саму двойную кавычку, то эту кавычку нужно удвоить.
%
%Перейдём теперь к пояснению структуры файла с описанием лексического анализатора (далее, для краткости, --- сканера).
%
%Прежде всего, если указана команда
%
%{\noindent%
%\textbf{\%scaner_name} \textcolor{Green}{\textit{имя_сканера}}
%}
%
%\noindent%
%то в одном из заголовочных файлов появляется запись вида
%\begin{verbatim}
%class имя_сканера {
%...
%};
%\end{verbatim}
%Сам же этот заголовочный файл будет называться \texttt{имя_сканера'.h}. Соответствующий файл реализации будет называться \texttt{имя_сканера'.cpp}, где \texttt{имя_сканера'} --- \texttt{имя_сканера}, преобразованное к нижнему регистру. Принятое по умолчанию имя_сканера --- \texttt{Scaner}.
%
%Далее, если указана команда
%
%{\noindent%
%\textbf{\%codes_type} \textcolor{Green}{\textit{имя_типа_кодов_лексем}}
%}
%
%\noindent то раздел
%
%{\noindent%
%\textbf{\%codes}
%
%\textcolor{Green}{\textit{имя_кода_лексемы}}\texttt{\textcolor{Green}{\{}},\textcolor{Green}{\textit{имя_кода_лексемы}}\texttt{\textcolor{Green}{\}}}
%}
%
%\noindent%
%порождает в файле \texttt{имя_сканера'.h} запись вида 
%\begin{verbatim}
%enum имя_типа_кодов_лексем : unsigned short {
%    NONE,
%    UNKNOWN,
%    имя_кода_лексемы1,
%    ...
%    имя_кода_лексемыN
%};
%\end{verbatim}
%где \texttt{имя_кода_лексемы1}, \dots, \texttt{имя_кода_лексемыN} ---  имена кодов лексем, определённые в разделе \textbf{\%codes}.  Принятое по умолчанию имя типа кодов лексем --- \texttt{Lexem_code}.
%
%Команда
%
%\noindent%
%\textbf{\%ident_name} \textcolor{Green}{\textit{имя_идентификатора}}
%
%\noindent указывает имя кода лексемы для лексемы 'идентификатор'. Если в языке, для которого пишется сканер, идентификаторов нет, то команда \textbf{\%ident_name} необязательна.
%
%Если в начало заголовочного файла генерируемого сканера нужно добавить какой--либо текст, то нужно указать команду
%
%\noindent%
%\textbf{\%header_additions}  \textcolor{Green}{\textit{дополнения_для_заголовочного_файла}}
%
%\noindent%
%Здесь  \textcolor{Green}{\textit{дополнения_для_заголовочного_файла}} --- строковый литерал с добавляемым текстом.
%
%Аналогично, если в начало файла реализации генерируемого сканера нужно добавить какой--либо текст, то нужно указать команду
%
%\noindent%
%\textbf{\%impl_additions}  \textcolor{Green}{\textit{дополнения_для_файла_реализации}}
%
%\noindent%
%Здесь  \textcolor{Green}{\textit{дополнения_для_файла_реализации}} --- строковый литерал с добавляемым текстом.
%
%Команда 
%
%\noindent%
%\textbf{\%lexem_info_name}  \textcolor{Green}{\textit{имя_типа_со_сведениями_о_лексеме}}
%
%\noindent%
%определяет имя типа со сведениями о лексеме. Принятое по умолчанию имя типа --- \texttt{Lexem_info}.
%
%
%Если в описание лексемы нужно добавить какие--либо поля, то необходимо написать команду
%
%\noindent%
%\textbf{\%token_fields} \textcolor{Green}{\textit{добавляемые_поля_лексемы}}
%
%\noindent где \textcolor{Green}{\textit{добавляемые_поля_лексемы}} --- строковый литерал с описанием нужных полей. Например, если лексема может принимать как значения типа
%\texttt{__float128}, так и значения типа \texttt{__int128}, причём поле типа \texttt{__float128} по условиям задачи нужно назвать \texttt{x}, а поле типа  \texttt{__int128} ---
%\texttt{y}, то строковый литерал с добавляемыми в лексему полями может выглядеть, например, так:
%
%\noindent% 
%"__float128 x;\\
%__int128    y;"
%
%Кроме того, если в класс сканера требуется добавить члены, необходимые для каких--либо вычислений, то нужно написать
%
%\noindent%
%\textbf{\%class_members} \textcolor{Green}{\textit{добавляемые_члены_класса}}
%
%\noindent %
%где под \textcolor{Green}{\textit{добавляемые_члены_класса}} понимается строковый литерал, содержащий перечень добавляемых в сканер членов. Если, например, нужно добавить 
%
%\noindent%
%\texttt{%
%__int128   integer_value;\\
%__float128 integer_part;\\
%__float128 fractional_part;\\
%__float128 exponent;
%}
%
%\noindent то вместо \textcolor{Green}{\textit{добавляемые_члены_класса}} нужно написать
%
%\noindent% 
%"__int128   integer_value;\\
%__float128 integer_part;\\
%__float128 fractional_part;\\
%__float128 exponent;"
%
%Если необходимо, чтобы символ \verb"'\n'" перехода на новую строку был отдельной лексемой, а не пробельным символом, то нужно указать команду 
%\textbf{\%newline_is_lexem}.
%
%В обязательном разделе  \textbf{\%codes} содержится список разделённых запятыми идентификаторов (правила построения идентификаторов --- такие же, что и в C++), представляющих 
%собой имена кодов лексем. 
%
%Например, если имя перечисления с кодами лексемы не указано командой \textbf{\%codes_type}, и раздел  \textbf{\%codes} имеет вид
%
%\noindent%
%\textbf{\%codes} 
%
%Kw_if, Kw_then, Kw_else, Kw_endif
%
%\noindent то будет порождено перечисление
%\begin{verbatim}
%enum Lexem_code : unsigned short {
%    NONE,    UNKNOWN,
%    Kw_if,   Kw_then, 
%    Kw_else, Kw_endif
%};
%\end{verbatim}
%
%Иными словами, всегда определяется два специальных кода лексем: \texttt{NONE}, обозначающее конец обрабатываемого текста, и \texttt{UNKNOWN}, обозначающее неизвестную лексему.
%
%В разделе \textbf{\%keywords} указываются ключевые слова языка, для которого пишется сканер, и соответствующие этим ключевым словам коды лексем, взятые из
%раздела \textbf{\%codes}. 
%Например, если имеются ключевые слова \textbf{if}, \textbf{then}, \textbf{else}, \textbf{endif}, и этим ключевым словам соответствуют коды лексем
%\texttt{Kw_if}, \texttt{Kw_then}, \texttt{Kw_else}, \texttt{Kw_endif}, то раздел \textbf{\%keywords} должен иметь следующий вид:
%\begin{verbatim}
%%keywords
%    ...
%    "if" : Kw_if,
%    "then" : Kw_then,
%    "else" : Kw_else,
%    "endif" : Kw_endif
%    ...
%\end{verbatim}
%Здесь многоточием обозначено (возможно, имеющееся) описание других ключевых слов.
%
%В разделе \textbf{\%idents} определяется структура идентификатора того языка, для которого пишется сканер. Более точно, 
%\textcolor{Green}{\textit{описание_начала_идентификатора}} указывает, что может быть в начале идентификатора, а \textcolor{Green}{\textit{описание_тела_идентификатора}} --- как
%устроено тело идентификатора.
%
%В разделе \textbf{\%delimiters} указываются разделители и знаки операций языка, для которого пишется сканер, и соответствующие этим разделителям и знакам
%операций коды лексем, взятые из раздела \textbf{\%codes}. Например, если в языке есть разделители \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{=}, \texttt{!=},
%с соответствующими кодами лексем \texttt{del_LT}, \texttt{del_GT}, \texttt{del_LEQ}, \texttt{del_GEQ}, \texttt{del_EQ}, \texttt{del_NEQ}, то раздел \textbf{\%delimiters}
%должен иметь вид
%\begin{verbatim}
%%delimiters
%    ...
%    "<"  : del_LT,
%    ">"  : del_GT,
%    "<=" : del_LEQ,
%    ">=" : del_GEQ,
%    "="  : del_EQ,
%    "!=" : del_NEQ
%    ...
%\end{verbatim} 
%Здесь многоточием обозначено (возможно, имеющееся) описание других разделителей и знаков операций.
%
%В разделе \textbf{\%numbers} указывается регулярное выражение, определяющее числа, с внедрёнными в это регулярное выражение действиями. Каждое из действий должно
%быть описано командой
%
%{\noindent%
%\textbf{\%action} \textcolor{Green}{\textit{имя_действия}} \textcolor{Green}{\textit{определение_действия}}
%}
%
%\noindent%
%где \textcolor{Green}{\textit{имя_действия}} --- идентификатор языка C++, являющийся именем определяемого действия, а \textcolor{Green}{\textit{определение_действия}} ---
%строковый литерал \texttt{myau}, содержащий код на C++, выполняющий нужное действие.
%
%В разделе \textbf{\%strings} описывается структура строковых и символьных литералов (если символьные литералы вообще есть) языка, для которого пишется сканер.
%Раздел \textbf{\%strings} устроен так же, как и раздел \textbf{\%numbers}. При этом при указании раздела
%\textbf{\%strings} у класса сканера автоматически определяются члены \texttt{std::string buffer} и \texttt{int char_code}.
%
%Наконец, в разделе \textbf{\%comments} описывается структура комментариев языка, для которого пишется сканер.
%
%Командой 
%
%{\noindent%
%\textbf{\%single_lined} \textcolor{Green}{\textit{начало_однострочного_комментария}}
%}
%
%\noindent%
%где \textcolor{Green}{\textit{начало_однострочного_комментария}} --- строковый литерал, представляющий цепочку символов, являющуюся началом однострочного
%комментария, определяется структура однострочного комментария.
%
%Командой же
%
%{\noindent%
%\textbf{\%multilined} \texttt{\textcolor{Green}{[}}%
%\textbf{\%nested}\texttt{\textcolor{Green}{]}}
%
%\textcolor{Green}{\textit{начало_многострочного_комментария}} :
%\textcolor{Green}{\textit{конец_многострочного_комментария}}
%}
%
%\noindent%
%определяется структура многострочного комментария. 
%
%А именно, \textcolor{Green}{\textit{начало_многострочного_комментария}} и \textcolor{Green}{\textit{конец_многострочного_комментария}} --- строковые литералы, являющиеся
%цепочками символов, начинающих и заканчивающих многострочный комментарий. Если указано слово \textbf{\%nested}, то многострочный комментарий может быть вложенным.
%
%Поясним теперь, что в \texttt{Myau} понимается под началом идентификатора, концом идентификатора, и регулярным выражением:
%
%\textcolor{Green}{\synt{описание_начала_идентификатора} $\to$ }\textcolor{Green}{\synt{выр}}
%
%\textcolor{Green}{\synt{описание_тела_идентификатора} $\to$ }\textcolor{Green}{\synt{выр}}
%
%\textcolor{Green}{\synt{выр} $\to$ \synt{выр}$_0$\texttt{\{}\textcolor{Black}{|}\synt{выр}$_0$\texttt{\}}}
%
%\textcolor{Green}{\synt{выр}$_0$ $\to$ \synt{выр}$_1$\texttt{\{}\synt{выр}$_1$\texttt{\}}}
%
%%\textcolor{Green}{\synt{выр}$_1$ $\to$ \synt{выр}$_2$\texttt{[}\textcolor{Black}{?}|\textcolor{Black}{*}|\textcolor{Black}{+}\texttt{]}}
%
%\textcolor{Green}{\synt{выр}$_1$ $\to$ \textcolor{Black}{символ} | \synt{класс_символов}}
%
%\textcolor{Green}{\synt{класс_символов} $\to$ \texttt{\textcolor{Black}{[:Latin:]}} | \texttt{\textcolor{Black}{[:latin:]}} | \texttt{\textcolor{Black}{[:Russian:]}} |
%\texttt{\textcolor{Black}{[:russian:]}} | \texttt{\textcolor{Black}{[:bdigits:]}} |\\
%{}\texttt{\textcolor{Black}{[:odigits:]}} | \texttt{\textcolor{Black}{[:digits:]}} | \texttt{\textcolor{Black}{[:xdigits:]}} | \texttt{\textcolor{Black}{[:Letter:]}} |
%\texttt{\textcolor{Black}{[:letter:]}} | \texttt{\textcolor{Black}{[:nsq:]}} | \texttt{\textcolor{Black}{[:ndq:]}} }
%
%\textcolor{Green}{\synt{выражение} $\to$ \synt{выражение}$_0$ \texttt{\{}\textcolor{Black}{|}\synt{выражение}$_0$ \texttt{\}}
%}
%
%\textcolor{Green}{\synt{выражение}$_0$ $\to$ \synt{выражение}$_1$ \texttt{\{}\synt{выражение}$_1$\texttt{\}}
%}
%
%\textcolor{Green}{\synt{выражение}$_1$ $\to$ \synt{выражение}$_2$\texttt{[}\textcolor{Black}{?}|\textcolor{Black}{*}|\textcolor{Black}{+}\texttt{]} }
%
%\textcolor{Green}{\synt{выражение}$_2$ $\to$ \synt{выражение}$_3$\texttt{[}\textcolor{Black}{\$}\synt{имя_действия}\texttt{]} }
%
%\textcolor{Green}{\synt{выражение}$_3$ $\to$ \textcolor{Black}{символ} | \synt{класс_символов} | \textcolor{Black}{(}\synt{выражение}\textcolor{Black}{)}}
%
%
%В этой грамматике под словом \glqq символ\grqq\ понимается следующее. Любой непробельный символ, кроме символов \texttt{'|'}, \texttt{'*'}, \texttt{'+'}, \texttt{'?'},
%'\texttt{\$'}, \texttt{'\textbackslash'}, \texttt{'"{}'}, и символа перехода на новую строку, в файле с описанием сканера представляет самого себя. Если же эти символы нужно
%указать в регулярном выражении, то следует их записывать как \texttt{'\textbackslash|'}, \texttt{'\textbackslash*'}, \texttt{'\textbackslash+'}, \texttt{'\textbackslash?'},
%'\texttt{\textbackslash\$'}, \texttt{'\textbackslash\textbackslash'}, \texttt{'\textbackslash"{}'}, \texttt{'\textbackslash{}n'} соответственно. При этом все пробельные 
%символы (то есть символы, коды которых не превосходят кода пробела) генератором лексических анализаторов Мяука игнорируются.
%
%В приводимой ниже таблице поясняются допускаемые классы символов. %\newpage
%
%\begin{table}[!h]
%\centering
%\caption{Допускаемые классы символов.}
%\vspace{1mm}
%\begin{tabular}{|l|p{125mm}|}\hline 
%Класс символов                          & Пояснение                                                                               \\ \hline
%\texttt{\textcolor{Black}{[:Latin:]}}   & Прописные латинские буквы от 'A' до 'Z'.                                                \\ \hline 
%\texttt{\textcolor{Black}{[:latin:]}}   & Строчные латинские буквы от 'a' до 'z'.                                                 \\ \hline 
%\texttt{\textcolor{Black}{[:Russian:]}} & Прописные русские буквы от 'А' до 'Я' (включая букву 'Ё').                              \\ \hline
%\texttt{\textcolor{Black}{[:russian:]}} & Строчные русские буквы от 'а' до 'я' (включая букву 'ё').                               \\ \hline
%\texttt{\textcolor{Black}{[:bdigits:]}} & Символы двоичных цифр, т.е. символы '0' и '1'.                                          \\ \hline
%\texttt{\textcolor{Black}{[:odigits:]}} & Символы восьмеричных цифр, т.е. символы '0', '1', '2', '3', '4', '5', '6', '7'.         \\ \hline
%\texttt{\textcolor{Black}{[:digits:]}}  & Символы десятичных цифр, т.е. символы '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. \\ \hline
%\texttt{\textcolor{Black}{[:xdigits:]}} & Символы шестнадцатеричных цифр, т.е. символы '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'.\\ \hline
%\texttt{\textcolor{Black}{[:Letter:]}}  & Прописные латинские буквы от 'A' до 'Z' и прописные русские буквы от 'А' до 'Я' (включая букву 'Ё').  \\ \hline
%\texttt{\textcolor{Black}{[:letter:]}}  & Строчные латинские буквы от 'a' до 'z' и строчные русские буквы от 'а' до 'я' (включая букву 'ё').    \\ \hline
%\texttt{\textcolor{Black}{[:nsq:]}}     & Символы, отличные от одинарной кавычки (').\\ \hline
%\texttt{\textcolor{Black}{[:ndq:]}}     & Символы, отличные от двойной кавычки (").\\ \hline
%\end{tabular} 
%\end{table}
%
%Из всех этих классов символов классы \texttt{\textcolor{Black}{[:nsq:]}} и \texttt{\textcolor{Black}{[:ndq:]}} допускаются только в разделе \textbf{\%strings}.
%
%    \section{Порождаемый программный код}
%Прежде чем описать порождаемый программный код, условимся, что все порождаемые файлы будут в кодировке UTF-8.
%
%Далее, порождаемому коду сканера потребуется подсчёт ошибок. Поэтому потребуется класс для подсчёта ошибок. Заголовочный файл будет называться \texttt{error_count.h}, а 
%файл реализации --- \texttt{error_count.cpp}. Содержимое этих файлов приводится в следующих двух листингах.
%
%\begin{minted}{c++}
%/* Файл error_count.h. */
%#ifndef ERROR_COUNT_H
%#define ERROR_COUNT_H
%  class Error_count {
%    public:
%      int get_number_of_errors();
%      void increment_number_of_errors();
%      void print_number_of_errors();
%      Error_count() : number_of_errors(0) {};
%    private:
%      int number_of_errors;
%  };
%#endif
%\end{minted}
%\begin{minted}{c++}
%/* Файл error_count.cpp. */
%#include "error_count.h"
%#include <cstdio>
%
%int Error_count::get_number_of_errors(){
%  return number_of_errors;
%}
%
%void Error_count::increment_number_of_errors(){
%  ++number_of_errors;
%}
%
%void Error_count::print_number_of_errors(){
%  printf ("Всего ошибок: %d\n", number_of_errors); 
%}
%\end{minted}
%
%Далее, потребуется функция определения размера файла. Заголовочный файл назовём \texttt{fsize.h}, а файл реализации --- \texttt{fsize.cpp}. Содержимое этих файлов указано в двух следующих листингах.
%\begin{minted}{c++}
%/* Файл fsize.h. */
%#ifndef FSIZE_H
%#define FSIZE_H
%#include <cstdio>
%/* Данная функция выдаёт размер файла в байтах, если
%* fptr != NULL, и (-1) в противном случае. */
%long fsize(FILE* fptr);
%#endif
%\end{minted}
%
%\begin{minted}{c++}
%/* Файл fsize.cpp. */
%#include "../include/fsize.h"
%#include <cstdio>
%long fsize(FILE* fptr){
%    long ret_val = -1;
%    if(fptr){
%        long current_pos = ftell(fptr);
%        fseek(fptr, 0L, SEEK_END);
%        ret_val = ftell(fptr);
%        fseek(fptr, current_pos, SEEK_SET);
%    }
%    return ret_val;
%}
%\end{minted}
%
%Вся внутренняя обработка текста будет вестись для кодировки UTF32, при этом каждый символ будет иметь тип char32_t. При этом считаем, что файлы с текстом, 
%обрабатываемые сгенерированным сканером, будут в кодировке UTF-8. В связи с этим потребуется, во--первых, функция, читающая всё содержимое файла, и, во--вторых, функция, преобразующая строки и символы из кодировки UTF32 в кодировку UTF-8 и обратно. Ниже приведены соответстующие заголовочные файлы и файлы реализации.
%\begin{minted}{c++}
%/* Файл char_conv.h.*/
%/**
%\file
%
%\brief Заголовочный файл с прототипами функций, преобразующих строки из кодировки
%UTF-8 в кодировку UTF-32 и наоборот.
%*/
%
%#ifndef CHAR_CONV_H
%#define CHAR_CONV_H
%
%#include <string>
%
%/**
%\function utf8_to_u32string
% Данная функция по строке в кодировке UTF-8 строит строку в кодировке UTF-32.
%
%\param  utf8str – строка в кодировке UTF-8 с завершающим нулевым символом
%
%\return значение типа std::u32string, представляющее собой ту же строку,
% но в кодировке UTF-32
%*/
%std::u32string utf8_to_u32string(const char* utf8str);
%
%/**
%\function u32string_to_utf8
% Данная функция по строке в кодировке UTF-32 строит строку в кодировке UTF-8.
%
%\param [in] u32str – строка в кодировке UTF-32
%
%\return значение типа std::string, представляющее собой ту же строку,
% но в кодировке UTF-8
%*/
%std::string u32string_to_utf8(const std::u32string& u32str);
%
%/**
%\function char32_to_utf8
%По символу в кодировке UTF-32 строит строку, состоящую из байтов, представляющих
%тот же символ, но в кодировке UTF-8.
%
%\param [in] с - символ в кодировке UTF-32
%
%\return Значение типа std::string, состоящее из байтов, представляющих
%тот же символ, но в кодировке UTF-8.
%*/
%std::string char32_to_utf8(const char32_t c);
%#endif
%\end{minted}
%
%\begin{minted}{c++}
%/* Файл file_contents.h. */
%#ifndef FILE_CONTENTS_H
%#define FILE_CONTENTS_H
%#include <string>
%#include <utility>
%
%/** Коды возврата из функции get_contents. */
%enum class Get_contents_return_code{
%    Normal,           ///< Этот код означает, что всё прошло успешно.
%    Impossible_open,  ///< Этот код означает, что не удалось открыть файл.
%    Read_error        ///< Этот код означает, что во время чтения файла произошла ошибка.
%};
%
%using Contents  = std::pair<Get_contents_return_code, std::string>;
%
%/**
%   Возвращает всё содержимое файла с заданным именем.
%   \param [in] name --- имя читаемого файла
%   \returns Пару из кода возврата (первая компонента) и значения, имеющего
%тип std::string (вторая компонента). При возникновении ошибки вторая компонента
%возвращаемого значения представляет собой пустую строку.
%*/
%Contents get_contents(const char* name);
%#endif
%\end{minted}
%
%\begin{minted}{c++}
%/* Файл char_conv.cpp.  */
%#include "../include/char_conv.h"
%
%std::string char32_to_utf8(const char32_t c){
%    std::string s;
%    char c1, c2, c3, c4;
%    char32_t temp = c;
%    switch(c){
%        case 0x0000'0000 ... 0x0000'007f:
%            s += static_cast<char>(c);
%            break;
%
%        case 0x0000'0080 ... 0x0000'07ff:
%            c1 = 0b110'0'0000 | (temp >> 6);
%            c2 = 0b10'00'0000 | (temp & 0b111'111);
%            s += c1; s += c2;
%            break;
%
%        case 0x0000'0800 ... 0x0000'ffff:
%            c3 = 0b10'00'0000 | (temp & 0b111'111);
%            temp >>= 6;
%            c2 = 0b10'00'0000 | (temp & 0b111'111);
%            temp >>= 6;
%            c1 = 0b1110'0000 | c;
%            s += c1; s += c2; s += c3;
%            break;
%
%        case 0x0001'0000 ... 0x001f'ffff:
%            c4 = 0b10'00'0000 | (temp & 0b111'111);
%            temp >>= 6;
%            c3 = 0b10'00'0000 | (temp & 0b111'111);
%            temp >>= 6;
%            c2 = 0b10'00'0000 | (temp & 0b111'111);
%            temp >>= 6;
%            c1 = 0b11110'000 | c;
%            s += c1; s += c2; s += c3; s += c4;
%            break;
%
%        default:
%            ;
%    }
%    return s;
%}
%
%std::string u32string_to_utf8(const std::u32string& u32str){
%    std::string s;
%    for(const char32_t c : u32str){
%        s += char32_to_utf8(c);
%    }
%    return s;
%}
%
%std::u32string utf8_to_u32string(const char* utf8str){
%    std::u32string s;
%    enum class State{
%        Start_state,                 Three_byte_char_second_byte,
%        Four_byte_char_second_byte,  Four_byte_char_third_byte,
%        Last_byte_of_char
%    };
%    State state = State::Start_state;
%    char32_t current_char = 0;
%    while(char c = *utf8str++){
%        switch(state){
%            case State::Start_state:
%                if(c >= 0){
%                    s += c;
%                }else if((c & 0b1110'0000) == 0b1100'0000){
%                    current_char = c & 0b0001'1111;
%                    state = State::Last_byte_of_char;
%                }else if((c & 0b1111'0000) == 0b1110'0000){
%                    current_char = c & 0b0000'1111;
%                    state = State::Three_byte_char_second_byte;
%                }else if((c & 0b1111'1000) == 0b1111'0000){
%                    current_char = c & 0b0000'0111;
%                    state = State::Four_byte_char_second_byte;
%                }
%                break;
%
%            case State::Last_byte_of_char:
%                current_char = (current_char << 6) | (c & 0b0011'1111);
%                s += current_char;
%                state = State::Start_state;
%                break;
%
%            case State::Three_byte_char_second_byte:
%                current_char = (current_char << 6) | (c & 0b0011'1111);
%                state = State::Last_byte_of_char;
%                break;
%
%            case State::Four_byte_char_second_byte:
%                current_char = (current_char << 6) | (c & 0b0011'1111);
%                state = State::Four_byte_char_third_byte;
%                break;
%
%            case State::Four_byte_char_third_byte:
%                current_char = (current_char << 6) | (c & 0b0011'1111);
%                state = State::Last_byte_of_char;
%                break;
%        }
%    }
%    return s;
%}
%\end{minted}
%\begin{minted}{c++}
%/* Файл file_contents.cpp. */
%#include "../include/file_contents.h"
%#include "../include/fsize.h"
%#include <cstdio>
%#include <memory>
%
%Contents get_contents(const char* name){
%    Contents result = std::make_pair(Get_contents_return_code::Normal, "");
%    FILE* fptr = fopen(name, "rb");
%    if(!fptr){
%        result.first = Get_contents_return_code::Impossible_open;
%        return result;
%    }
%    long file_size = fsize(fptr);
%    if(!file_size){
%        return result;
%    }
%    auto   test_text = std::make_unique<char[]>(file_size + 1);
%    char*  q         = test_text.get();
%    size_t fr        = fread(q, 1, file_size, fptr);
%    if(fr < (unsigned long)file_size){
%        fclose(fptr);
%        result.first = Get_contents_return_code::Read_error;
%        return result;
%    }
%    test_text[file_size] = 0;
%    fclose(fptr);
%    result.second = std::string(test_text.get());
%    return result;
%}
%\end{minted}
%
%Далее, в сгенерированных файлах используется проверка принадлежности неотрицательного целого числа, находящегося в диапазоне от 0 до 63, множеству таких 
%чисел. Для этого нужен приводимый ниже файл \texttt{belongs.h}.
%\begin{minted}{c++}
%#ifndef BELONGS_H
%#define BELONGS_H
%/* Данная функция проверяет, принадлежит ли элемент element множеству s. При этом
% * считаем, что множество s состоит из не более чем 64 элементов, так что в качестве
% * внутреннего представления множества используется тип uint64_t. Если бит с номером
% * i внутреннего представления равен 1, то элемент i принадлежит множеству,
% * иначе --- не принадлежит. */
%inline uint64_t belongs(uint64_t element, uint64_t s){
%    return s & (1ULL << element);
%}
%#endif
%\end{minted}
%
%Для случая проверки принадлежности числа большему множеству нужен файл \texttt{operations_with_sets.h}:
%\begin{minted}{c++}
%#ifndef OPERATIONS_WITH_SETS_H 
%#define OPERATIONS_WITH_SETS_H
%
%#include <set>
%#include <cstdio>
%/**
%    В данном файле определяются теоретико--множественные операции
%    со стандартными контейнерами std::set.
%*/
%namespace operations_with_sets{
%    //! Функция single_elem возвращает множество, состоящее из одного элемента.
%    template<typename T>
%    std::set<T> single_elem(const T& x){
%        std::set<T> s;
%        s.insert(x);
%        return s;
%    }
%
%    /** Функция печати элементов множества. Принимает в качестве
%        аргумента функцию печати элемента множества. */
%    template<typename T>
%    void print_set(const std::set<T>& a, void (*print_elem)(const T&)){
%        if(a.empty()){
%            printf("{}");
%            return;
%        }
%        auto first       = a.begin();
%        auto before_last = --a.end();
%        putchar('{');
%        for(auto i = first; i != before_last; ++i){
%            print_elem(*i);
%            putchar(',');
%        }
%        print_elem(*before_last);
%        putchar('}');
%    }
%
%    /** Проверка принадлежности элемента x множеству a. Если элемент x
%        множеству a принадлежит, то возвращается true, иначе ---
%        возвращается false. */
%    template<typename T>
%    bool is_elem(const T& x, const std::set<T>& a){
%        return a.find(x) != a.end();
%    }
%
%    /** Объединение множеств a и b, то есть множество, содержащее и
%        элементы множества a, и элементы множества b. */
%    template<typename T>
%    std::set<T> operator + (const std::set<T>& a, const std::set<T>& b){
%        std::set<T> s = a;
%        s.insert(b.begin(), b.end());
%        return s;
%    }
%
%    /** Теоретико--множественная разность множеств a и b (обозначается в
%        теории множеств как a \ b), то есть множество, состоящее лишь из тех
%        элементов множества a, которые не принадлежат множеству b. */
%    template<typename T>
%    std::set<T> operator - (const std::set<T>& a, const std::set<T>& b){
%        std::set<T> s = a;
%        for(const auto x : b){
%            s.erase(x);
%        }
%        return s;
%    }
%
%    /** Пересечение множеств a и b, то есть множество, состоящее в точности из
%        тех элементов, которые принадлежат и a, и b. */
%    template<typename T>
%    std::set<T> operator * (const std::set<T>& a, const std::set<T>& b){
%        std::set<T> s;
%        for(const auto& x : a){
%            if(is_elem(x, b)){
%                s.insert(x);
%            }
%        }
%        return s;
%    }
%
%    /** Симметрическая разность множеств a и b, то есть объединение этих
%        множеств с выкинутыми общими элементами. */
%    template<typename T>
%    std::set<T> operator ^ (const std::set<T>& a, const std::set<T>& b){
%        return (a - b) + (b - a);
%    }
%
%    /** Проверяет, является ли множество a подмножеством множества b,
%        возможно, совпадающим с b. */
%    template<typename T>
%    bool is_subseteq(const std::set<T>& a, const std::set<T>& b){
%        std::set<T> s = (a * b) ^ a;
%        return s.empty();
%    }
%};
%#endif
%\end{minted}
%
%Далее, для облегчения реализации таблиц символов строковые представления идентификаторов и строковых литералов хранятся в специальных таблицах, и в лексеме возвращается не строковое представление идентификатора или строкового литерала, а его индекс в таблице.
%
%При этом если в языке, для которого генерируется лексический анализатор (далее называемый сканером) имеются идентификаторы, то в структуру со сведениями о лексеме добавляется поле \texttt{size_t ident_index}, содержащее индекс идентификатора в таблице идентификаторов. Если же в языке, для которого генерируется сканер, имеются строковые литералы, то в структуру со сведениями о лексеме добавляются поле \texttt{size_t string_index}, содержащее индекс строкового литерала в таблице строковых литералов, и поле \texttt{char32_t c}, содержащее символьный литерал.
%
%Таблицы идентификаторов и строковых литералов представляют собой префиксные деревья (английское название --- trie).
%
%Под префиксным деревом здесь понимается структура данных, позволяющая хранить ассоциативный массив, ключами которого являются строки\footnote{В данном случае строки не обязаны состоять из символов в смысле какой--либо кодировки (кодировки DOS, Windows, и т.д.).}.
%
%Нагруженное дерево отличается от обычных n--арных деревьев тем, что в его узлах хранятся не ключи, а односимвольные метки. Ключом же, соответствующим некоторому узлу, является путь от корня дерева до этого узла, а точнее, строка составленная из меток узлов, повстречавшихся на этом пути. В таком случае корень дерева, очевидно, соответствует пустому ключу. Таким образом, потомки узла имеют общий префикс, откуда и произошло название данной структуры данных. Иные названия на русском языке --- бор \cite{KnuthV3-1978}, луч \cite{KnuthV3}, и нагруженное дерево \cite[с.152]{AhoHopcroftUllman}. Пример префиксного дерева (дерево для идентификаторов \texttt{get}, \texttt{her}, \texttt{him}, \texttt{his}):
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}[
%level distance=10mm,
%level 1/.style={sibling distance=15mm},
%level 2/.style={sibling distance=15mm},
%level 3/.style={sibling distance=15mm},
%level 4/.style={sibling distance=15mm}]
%\itshape\Large
%\node{$\bullet$}
%  child{node{g}
%    child{node{e}
%      child{node{t}}
%    }
%  }
%  child{node{h}
%    child{node{e}
%      child{node{r}}
%    }
%    child{node{i}
%      child{node{m}}
%      child{node{s}}
%    }
%  };
%\end{tikzpicture}}
%\caption{Префиксное дерево для идентификаторов \texttt{get}, \texttt{her}, \texttt{him}, \texttt{his}.}\label{Prefix.tree.example}
%\end{figure}
%
%Внутреннее представление будет таким:
%\begin{figure}[!h]
%\centering
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=0.5pt,semithick},
%    post/.style={->,shorten >=0.5pt,semithick},
%    trie node/.style={draw=black,thick, inner sep=0pt,minimum height=5mm,minimum width=11mm},
%    font = \itshape]
%\matrix[row sep=6mm,column sep=7mm] {
%                           & \node[trie node](root){0x00}; &                          &                          &                          \\
%  \node[trie node](n7){g}; &                               & \node[trie node](n8){h}; &                          &                          \\
%  \node[trie node](n4){e}; &                               & \node[trie node](n5){e}; & \node[trie node](n6){i}; &                          \\
%  \node[trie node](n0){t}; &                               & \node[trie node](n1){r}; & \node[trie node](n2){m}; & \node[trie node](n3){s}; \\
%};
%\path (n7)   edge[post]             (root)
%             edge[post]             (n8)
%             edge[post, bend right] (n4)
%      (n8)   edge[post]             (root)
%             edge[post, bend right] (n5)
%      (n4)   edge[post, bend right] (n0)
%             edge[post]             (n7)
%      (n5)   edge[post]             (n8)
%             edge[post]             (n6)
%             edge[post, bend right] (n1)
%      (n6)   edge[post]             (n8)
%             edge[post, bend right] (n2)
%      (n0)   edge[post]             (n4)
%      (n1)   edge[post]             (n5)
%      (n2)   edge[post]             (n6)
%             edge[post]             (n3)
%      (n3)   edge[post]             (n6)
%      (root) edge[post, bend right] (n7)
%             edge[post, bend left]  (n8); 
%\end{tikzpicture}}
%\caption{Внутреннее представление префиксного дерева для идентификаторов \texttt{get}, \texttt{her}, \texttt{him}, \texttt{his}.}\label{inner.repres.for.ids.get.her.him.his}
%\end{figure}
%
%Поясним рисунок \ref{inner.repres.for.ids.get.her.him.his}. Каждый узел помечен символом типа \texttt{char32_t}. А именно, корень помечен символом с кодом ноль. Потомки корня помечены первыми символами вставленных строк. Если узел не является корнем, то его потомки помечаются символами, которые во вставленных строках идут сразу же после префикса, получающегося проходом от корня до этого узла. Например, потомки крайнего правого узла на третьем уровне изображённого на
%рис.~\ref{inner.repres.for.ids.get.her.him.his} дерева (этот узел помечен символом $i$) помечены символами $m$ и $s$. Для этого узла префикс, получающийся проходом от корня, представляет собой строку $hi$, являющуюся префиксом идентификаторов \texttt{him} и \texttt{his}. 
%
%У каждого узла, изображённого на рис.~\ref{inner.repres.for.ids.get.her.him.his}, помимо поля, содержащего символ, который помечает узел, имеются также поля--указатели. А именно, имеются следующие поля: указатель на узел--предок, указатель на следующий потомок узла--предка, и указатель на список узлов--потомков. Все узлы--потомки организованы в виде односвязного списка. При этом под указателем на список узлов--потомков понимается указатель на первый элемент списка.
%
%Чтобы явно не выделять память, узлы будем хранить в стандартном контейнере \texttt{vector}. Новые узлы будем добавлять в конец контейнера. Поскольку все узлы хранятся в контейнере \texttt{vector}, то поля--указатели заменить полями--индексами. Иными словами, каждый узел реализован в виде структуры, хранящей следующие данные:
%\begin{enumerate}
%\item символ, которым помечен узел;
%\item целочисленное значение, хранящее индекс узла--предка в контейнере \texttt{vector};
%\item целочисленное значение, хранящее индекс в контейнере \texttt{vector} первого элемента в односвязном списке узлов--потомков;
%\item целочисленное значение, хранящее индекс в контейнере \texttt{vector} следующего потомка узла--предка.
%\end{enumerate}
%
%Реализация пустого префиксного дерева такова: контейнер \texttt{vector}, содержащий узлы, содержит единственный узел (корень дерева), помеченный символом с кодом 0, и все поля--индексы которого равны нулю.
%
%Далее, синтаксическому анализатору нужно выводить идентификаторы при выводе сообщений об ошибках (например, при обнаружении несовместимости типов и при обнаружении идентификатора, который используется, но не описан) по известным индексам идентификаторов в таблице идентификаторов. Для упрощения вывода идентификаторов на экран добавим к внутреннему представлению узла поле, равное длине пути от корня до данного узла.
%
%Поясним, как осуществляется вставка в префиксное дерево. Рассмотрим сначала случай вставки в пустое дерево. Вставлять будем идентификатор \texttt{get}. Итак, до вставки дерево выглядело так:
%\begin{center}
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=0.5pt,semithick},
%    post/.style={->,shorten >=0.5pt,semithick},
%    trie node/.style={draw=black,thick, inner sep=0pt,minimum height=5mm,minimum width=11mm},
%    font = \itshape]
%\matrix[row sep=7mm,column sep=7mm] {
%   \node[trie node](root){0x00}; \\
%};
%\end{tikzpicture}}
%\end{center}
%При вставке идентификатора \texttt{get} нужно последовательно пройти по всем символам этого идентификатора. Первый символ идентификатора \texttt{get} --- символ '\texttt{g}'. Поскольку дерево пусто, то оно состоит только из корня, и, следовательно, корень дерева не имеет потомков. Поэтому в список потомков корня нужно вставить узел, помеченный первым символом вставляемого идентификатора, то есть символом '\texttt{g}'. После этого дерево примет вид
%\begin{center}
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=0.5pt,semithick},
%    post/.style={->,shorten >=0.5pt,semithick},
%    trie node/.style={draw=black,thick, inner sep=0pt,minimum height=5mm,minimum width=11mm},
%    font = \itshape]
%\matrix[row sep=4mm,column sep=7mm] {
%                           & \node[trie node](root){0x00}; \\
%  \node[trie node](n7){g}; &                               \\
%};
%\path (n7)   edge[post]             (root)
%      (root) edge[post, bend right] (n7); 
%\end{tikzpicture}}
%\end{center}
%Теперь считаем вставленный узел корнем поддерева, и в это поддерево вставляем оставшуюся часть идентификатора, то есть строку \texttt{et}. Первым символом этой строки является символ '\texttt{e}'. Поскольку корень рассматриваемого поддерева не имеет потомков, то в список потомков корня рассматриваемого поддерева нужно вставить узел, помеченный первым символом вставляемой строки \texttt{et}, то есть символом '\texttt{e}'. После этого дерево примет вид
%\begin{center}
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=0.5pt,semithick},
%    post/.style={->,shorten >=0.5pt,semithick},
%    trie node/.style={draw=black,thick, inner sep=0pt,minimum height=5mm,minimum width=11mm},
%    font = \itshape]
%\matrix[row sep=4mm,column sep=7mm] {
%                           & \node[trie node](root){0x00}; \\
%  \node[trie node](n7){g}; &                               \\
%  \node[trie node](n4){e}; &                               \\
%};
%\path (n7)   edge[post]             (root)
%             edge[post, bend right] (n4)
%      (n4)   edge[post]             (n7)
%      (root) edge[post, bend right] (n7); 
%\end{tikzpicture}}
%\end{center}
%Считаем вставленный узел корнем поддерева, и в это поддерево вставляем оставшуюся часть идентификатора, то есть строку \texttt{t}. Первым (и единственным) символом данной строки является символ '\texttt{t}'. Поскольку корень рассматриваемого поддерева не имеет потомков, то в список потомков корня рассматриваемого поддерева нужно вставить узел, помеченный первым символом вставляемой строки \texttt{t}, то есть символом '\texttt{t}'. Итак, после вставки идентификатора \texttt{get} в пустое дерево получим следующее префиксное дерево:
%\begin{center}
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=0.5pt,semithick},
%    post/.style={->,shorten >=0.5pt,semithick},
%    trie node/.style={draw=black,thick, inner sep=0pt,minimum height=5mm,minimum width=11mm},
%    font = \itshape]
%\matrix[row sep=4mm,column sep=7mm] {
%                           & \node[trie node](root){0x00}; \\
%  \node[trie node](n7){g}; &                               \\
%  \node[trie node](n4){e}; &                               \\
%  \node[trie node](n0){t}; &                               \\
%};
%\path (n7)   edge[post]             (root)
%             edge[post, bend right] (n4)
%      (n4)   edge[post, bend right] (n0)
%             edge[post]             (n7)
%      (n0)   edge[post]             (n4)
%      (root) edge[post, bend right] (n7); 
%\end{tikzpicture}}
%\end{center}
%
%Рассмотрим теперь следующее префиксное дерево, содержащее идентификаторы \texttt{get}, \texttt{her}, \texttt{him}:
%\begin{center}
%{\begin{tikzpicture}
%    [skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}},
%    pre/.style={<-,shorten <=0.5pt,semithick},
%    post/.style={->,shorten >=0.5pt,semithick},
%    trie node/.style={draw=black,thick, inner sep=0pt,minimum height=5mm,minimum width=11mm},
%    font = \itshape]
%\matrix[row sep=7mm,column sep=7mm] {
%                           & \node[trie node](root){0x00}; &                          &                          \\
%  \node[trie node](n7){g}; &                               & \node[trie node](n8){h}; &                          \\
%  \node[trie node](n4){e}; &                               & \node[trie node](n5){e}; & \node[trie node](n6){i}; \\
%  \node[trie node](n0){t}; &                               & \node[trie node](n1){r}; & \node[trie node](n2){m}; \\
%};
%\path (n7)   edge[post]             (root)
%             edge[post]             (n8)
%             edge[post, bend right] (n4)
%      (n8)   edge[post]             (root)
%             edge[post, bend right] (n5)
%      (n4)   edge[post, bend right] (n0)
%             edge[post]             (n7)
%      (n5)   edge[post]             (n8)
%             edge[post]             (n6)
%             edge[post, bend right] (n1)
%      (n6)   edge[post]             (n8)
%             edge[post, bend right] (n2)
%      (n0)   edge[post]             (n4)
%      (n1)   edge[post]             (n5)
%      (n2)   edge[post]             (n6)
%      (root) edge[post, bend right] (n7)
%             edge[post, bend left]  (n8); 
%\end{tikzpicture}}
%\end{center}
%Вставим в это дерево идентификатор \texttt{his}. Первым символом вставляемого идентификатора является символ '\texttt{h}'. Поскольку у корня префиксного дерева есть потомок, помеченный указанным символом, то вставляем оставшуюся часть идентификатора, строку \texttt{is}, в поддерево, корнем которого является потомок корня дерева, помеченный  символом '\texttt{h}'. Среди потомков корня рассматриваемого поддерева есть узел, помеченный первым символом строки \texttt{is}, то есть символом '\texttt{i}'. Поэтому в поддерево, корнем которого является помеченный символом '\texttt{i}' узел, нужно вставить оставшуюся часть идентификатора \texttt{his}, строку \texttt{s}. У корня того поддерева, в котором находимся в настоящий момент, имеется потомок, помеченный символом '\texttt{m}', но нет потомка, помеченного символом '\texttt{s}'. Следовательно, нужно в список потомков вставить корня текущего поддерева вставить узел, помеченный символом '\texttt{s}'. В результате получим дерево, изображённое на рис.~\ref{inner.repres.for.ids.get.her.him.his}.
%
%Класс префиксного дерева для строковых литералов и для идентификаторов будет наследником класса префиксного дерева, параметризованного типом хранимых в узлах данных. Параметризованный класс префиксного дерева будет находиться в файле \texttt{trie.h}, содержимое которого приводится ниже.
%\begin{minted}{c++}
%/* Файл trie.h. */
%#ifndef TRIE_H
%#define TRIE_H
%
%#include <vector>
%#include <map>
%#include <utility>
%#include <algorithm>
%#include <string>
%#include <set>
%
%template<typename T>
%class Trie {
%public:
%    /* Конструктор по умолчанию. */
%    Trie<T>();
%    /* Деструктор. */
%    ~Trie() = default;
%    /* Копирующий конструктор. */
%    Trie(const Trie<T>& orig) = default;
%    /* Функция вставки в префиксное дерево. */
%    size_t insert(const std::basic_string<T>& s);
%    /* Функция, вычисляющая максимальную степень вершин префиксного
%     * дерева (корень дерева не учитывается). */
%    size_t maximal_degree();
%protected:
%    /* тип узла префиксного дерева: */
%    struct node{
%      size_t parent, first_child, next;
%      /* Все узлы-потомки текущего узла организованы в виде односвязного списка, первым
%       * элементом которого является элемент с индексом first_child. В поле parent
%       * содержится индекс родительского узла, а в поле next -- следующего потомка
%       * родительского узла. Если у текущего узла потомков нет, то в поле first_child
%       * содержится нуль. Аналогично, последний элемент в списке потомков в поле next
%       * содержит нуль. Здесь под индексом понимается индекс в поле node_buffer,
%       * представляющем собой вектор (в смысле библиотеки STL) из узлов префиксного
%       * дерева. */
%      size_t path_len; /* в этом поле содержится длина пути
%                        * от текущего узла до корня дерева */
%      size_t degree; /* В этом поле содержится степень узла,
%                      * то есть количество выходящих из узла рёбер. */
%      T c; /* в этом поле содержится символ вставленной строки,
%            * являющийся меткой текущего узла. */
%      node(){
%        next = parent = path_len = first_child = 0;
%        degree = 0; c = T();
%      }
%    };
%    std::vector<node>   node_buffer;
%    std::vector<size_t> nodes_indeces;
%    /* Функция, добавляющая к списку потомков узла parent_idx узел, помеченный
%     * значением x типа T. Функция возвращает индекс вставленного узла. */
%    size_t add_child(size_t parent_idx, T x);
%    /* Эта функция выполняет (возможно, необходимые) действия
%     * по окончании вставки последнего символа. */
%    virtual void post_action(const std::basic_string<T>& s, size_t n){ };
%};
%
%template<typename T>
%Trie<T>::Trie(){
%    node_buffer = std::vector<node>(1);
%    nodes_indeces = std::vector<size_t>();
%}
%
%template<typename T>
%size_t Trie<T>::maximal_degree(){
%    size_t deg = 0;
%    size_t len = node_buffer.size();
%    for(int i = 1; i < len; i++){
%        deg = std::max(deg,node_buffer[i].degree);
%    }
%    return deg;
%}
%
%template<typename T>
%size_t Trie<T>::add_child(size_t parent_idx, T x){
%    size_t current, previous;
%    node   temp;
%    current = previous = node_buffer[parent_idx].first_child;
%    /* В переменной temp содержится узел, который, возможно, придётся вставить. */
%    temp.c = x; temp.degree = 0;
%    temp.next = 0; temp.parent = parent_idx;
%    temp.path_len = node_buffer[parent_idx].path_len + 1;
%    if(!current){
%        /* Здесь можем оказаться, лишь если у узла с индексом parent_idx потомков
%         * вообще нет. Значит добавляемый узел будет первым в списке потомков. При
%         * этом степень узла parent_idx увеличится на единицу, и станет равна 1. */
%        node_buffer.push_back(temp);
%        size_t child_idx = node_buffer.size() - 1;
%        node_buffer[parent_idx].first_child = child_idx;
%        node_buffer[parent_idx].degree = 1;
%        return child_idx;
%    }
%    while(current){
%        // Если же потомки есть, то нужно пройти по списку потомков.
%        node current_node = node_buffer[current];
%        if(current_node.c == x){
%          /* Если потомок, помеченный нужным символом (символом x),
%           * есть, то нужно вернуть индекс этого потомка. */
%          return current;
%        }else{
%          previous = current; current = current_node.next;
%        }
%    }
%    /* Если же такого потомка нет, то нужно этого потомка добавить
%     * в конец списка потомков.*/
%    node_buffer.push_back(temp);
%    size_t next_child = node_buffer.size() - 1;
%    node_buffer[previous].next = next_child;
%    node_buffer[parent_idx].degree++;
%    return next_child;
%}
%
%template<typename T>
%size_t Trie<T>::insert(const std::basic_string<T>& s){
%    ssize_t len = s.length();
%    size_t current_root = 0;
%    for (ssize_t i = 0; i < len; i++) {
%        current_root = add_child(current_root,s[i]);
%    }
%    nodes_indeces.push_back(current_root);
%    post_action(s,current_root);
%    return current_root;
%}
%#endif
%\end{minted}
%
%Описание префиксного дерева для идентификаторов и строковых литералов будет храниться в файле \texttt{char_trie.h}, а реализация --- в файле \texttt{char_trie.cpp}. Содержимое этих файлов приведено ниже.
%\begin{minted}{c++}
%/* Файл char_trie.h. */
%#ifndef CHAR_TRIE_H
%#define CHAR_TRIE_H
%
%#include "../include/trie.h"
%
%struct Char_trie_as_map {
%    std::map<size_t,char32_t*> *m;
%    ~Char_trie_as_map();
%};
%
%class Char_trie : public Trie<char32_t>{
%public:
%    virtual ~Char_trie() { };
%    /* Конструктор по умолчанию. */
%    Char_trie(){};
%    /* Копирующий конструктор. */
%    Char_trie(const Char_trie& orig) = default;
%    /* Функция, по индексу idx строящая строку в стиле C,
%     * соответствующую индексу idx. */
%    char32_t* get_cstring(size_t idx);
%    /* Функция, по индексу idx строящая строку типа u32string,
%       соответствующую индексу idx. */
%    std::u32string get_string(size_t idx);
%    /* Функция, возвращающая префиксное дерево в виде
%     * отображения индексов строк в строки в стиле C. */
%    Char_trie_as_map as_map();
%    /* Функция вывода строки, которой соответствует индекс idx, на экран. */
%    void print(size_t idx);
%    /* Следующая функция по индексу строки возвращает длину этой строки. */
%    size_t get_length(size_t idx);
%};
%
%#endif
%\end{minted}
%\begin{minted}{c++}
%/* Файл char_trie.cpp. */
%#include "../include/char_conv.h"
%#include "../include/char_trie.h"
%#include <vector>
%#include <map>
%#include <utility>
%#include <algorithm>
%#include <string>
%#include <set>
%
%Char_trie_as_map::~Char_trie_as_map(){
%    for(auto x : *m){
%        delete [] x.second;
%    }
%}
%
%Char_trie_as_map Char_trie::as_map(){
%    Char_trie_as_map t;
%    t.m = new std::map<size_t,char32_t*>();
%    for(auto x : nodes_indeces){
%        t.m -> insert({x,get_cstring(x)});
%    }
%    return t;
%}
%
%char32_t* Char_trie::get_cstring(size_t idx){
%    size_t id_len = node_buffer[idx].path_len;
%    char32_t* p = new char32_t[id_len + 1];
%    p[id_len] = 0;
%    size_t current = idx;
%    size_t i       = id_len-1;
%    /* Поскольку idx -- индекс элемента в node_buffer, содержащего последний символ
%     * вставленной строки, а каждый элемент вектора node_buffer содержит поле parent,
%     * указывающее на элемент с предыдущим символом строки, то для получения
%     * вставленной строки, которой соответствует индекс idx, в виде массива символов,
%     * нужно пройтись от элемента с индексом idx к корню. При этом символы вставленной
%     * строки будут читаться от её конца к началу. */
%    for( ; current; current = node_buffer[current].parent){
%        p[i--] = node_buffer[current].c;
%    }
%    return p;
%}
%
%std::u32string Char_trie::get_string(size_t idx){
%    char32_t* p = get_cstring(idx);
%    std::u32string s = std::u32string(p);
%    delete [] p;
%    return s;
%}
%
%void Char_trie::print(size_t idx){
%    std::u32string s32 = get_string(idx);
%    std::string    s8  = u32string_to_utf8(s32);
%    printf("%s",s8.c_str());
%}
%
%size_t Char_trie::get_length(size_t idx){
%    return node_buffer[idx].path_len;
%}
%\end{minted}
%
%Кроме того, генерируется файл \texttt{errors_and_tries.h}:
%\begin{minted}{c++}
%/* Файл errors_and_tries.h. */
%ifndef ERRORS_AND_TRIES_H
%#define ERRORS_AND_TRIES_H
%
%#include "../include/error_count.h"
%#include "../include/char_trie.h"
%#include <memory>
%struct Errors_and_tries{
%    std::shared_ptr<Error_count> ec;
%    std::shared_ptr<Char_trie>   ids_trie;
%    std::shared_ptr<Char_trie>   strs_trie;
%
%    Errors_and_tries()  = default;
%    ~Errors_and_tries() = default;
%};
%#endif
%\end{minted}
%
%Для порождения реализации автоматов, распознающих ряд видов лексем, нужна функция, ищущая символ в заканчивающейся символом с кодом ноль строке, состоящей из символов типа \texttt{char32_t}. Прототип этой функции содержится в файле \texttt{search_char.h}, а реализация --- в файле \texttt{search_char.cpp}. Ниже приведено содержимое каждого из этих файлов.
%\begin{minted}{c++}
%/* Файл search_char.h. */
%#define THERE_IS_NO_CHAR (-1)
%/**
% * \function search_char
% * Данная функция ищет заданный символ типа char32_t в строке,
% * состоящей из символов такого типа и завершающейся нулевым
% * символом.
% *
% * \param [in] c --- искомый символ
% * \param [in] array --- строка в которой ищется символ
% * \return смещение (в символах) от начала строки, если
% * искомый символ в строке есть, и (-1) в противном случае
% */
%int search_char(char32_t c, const char32_t* array);
%#endif
%\end{minted}
%\begin{minted}{c++}
%/* Файл search_char.cpp. */
%#include "../include/search_char.h"
%int search_char(char32_t c, const char32_t* array){
%    char32_t ch;
%    int      curr_pos = 0;
%    for(char32_t* p = const_cast<char32_t*>(array); (ch = *p++); ){
%        if(ch == c){
%            return curr_pos;
%        }
%        curr_pos++;
%    }
%    return THERE_IS_NO_CHAR;
%}
%\end{minted}
%
%Для инициализации ряда порождаемых автоматов потребуется функция, определяющая состояние, с которого автомат начнёт работу. Прототип функции будет содержаться в файле \texttt{get_init_state.h}, а реализация --- в файле \texttt{get_init_state.cpp}. Приведём содержимое этих файлов.
%\begin{minted}{c++}
%/* Файл get_init_state.h. */
%#ifndef GET_INIT_STATE_H
%#define GET_INIT_STATE_H
%
%struct State_for_char{
%    unsigned st;
%    char32_t c;
%};
%
%/* Функция get_init_state инициализирует конечный автомат. Делает она это так: ищет
% * символ sym в таблице sts, состоящей из пар (состояние, символ) и имеющей размер
% * n, двоичным поиском по второму компоненту пары. После нахождения выдаётся
% * первая компонента пары. В качестве алгоритма двоичного поиска используется
% * алгоритм B из раздела 6.2.1 монографии "Кнут Д.Э. Искусство программирования.
% * Т.3. Сортировка и поиск. 2-е изд.: Пер. с англ. --- М.: Вильямс, 2008.". При
% * этом в нашем случае не может быть, чтобы нужный элемент в таблице sts
% * отсутствовал. */
%int get_init_state(char32_t sym, const State_for_char sts[], int n);
%#endif
%\end{minted}
%\begin{minted}{c++}
%/* Файл get_init_state.cpp. */
%#include "../include/get_init_state.h"
%int get_init_state(char32_t sym, const State_for_char sts[], int n){
%    int lower, upper, middle;
%    lower = 0; upper = n - 1;
%    while(lower <= upper){
%        middle = (lower + upper) >> 1;
%        char32_t c_ = sts[middle].c;
%        if(sym == c_){
%            return sts[middle].st;
%        }else if(sym > c_){
%            lower = middle + 1;
%        }else{
%            upper = middle - 1;
%        }
%    }
%    return -1;
%}
%\end{minted}
%
%Сканеру нужно будет передавать обрабатываемый текст и указатель на текущее местоположение в этом тексте. Кроме того, бывает, что для разных кусков обрабатываемого текста требуются разные сканеры, и эти сканеры должны разделять сведения об обрабатываемом тексте и текущем в нём положении. Поэтому генерируется файл \texttt{location.h}, содержащий такие сведения:
%\begin{minted}{c++}
%/* Файл location.h. */
%#ifndef LOCATION_H
%#define LOCATION_H
%
%#include <memory>
%/* Следующая структура описывает текущее положение в обрабатываемом тексте.
% * В конструктор сканера нужно передавать умный указатель на
% * разделяемые сведения о текущем местоположении. */
%
%//#include <cstddef>
%struct Location {
%    char32_t* pcurrent_char; /* указатель на текущий символ */
%    size_t    current_line; /* номер текущей строки обрабатываемого текста */
%
%    Location() : pcurrent_char(nullptr), current_line(1) {};
%    Location(char32_t* txt) : pcurrent_char(txt), current_line(1) {};
%};
%
%using Location_ptr = std::shared_ptr<Location>;
%#endif
%\end{minted}
%
%Наконец, генерируемый сканер будет наследником шаблонного класса сканера. Шаблонны класс сканера содержится в файле \texttt{abstract_scaner.h}:
%\begin{minted}{c++}
%/* Файл abstract_scaner.h. */
%#ifndef ABSTRACT_SCANER_H
%#define ABSTRACT_SCANER_H
%
%#include <string>
%#include <memory>
%#include "../include/error_count.h"
%#include "../include/char_trie.h"
%#include "../include/location.h"
%#include "../include/errors_and_tries.h"
%
%template<typename Lexem_type>
%class Abstract_scaner{
%public:
%    Abstract_scaner<Lexem_type>() = default;
%    Abstract_scaner(Location_ptr location, const Errors_and_tries& et);
%    Abstract_scaner(const Abstract_scaner<Lexem_type>& orig) = default;
%    virtual ~Abstract_scaner() = default;
%    /* Функция back() возвращает текущую лексему во входной поток.*/
%    void back();
%    /* Функция current_lexem() возвращает сведения о текущей
%     * лексеме (код лексемы и значение лексемы). */
%    virtual Lexem_type current_lexem() = 0;
%    /* Функция lexem_begin_line_number() возвращает номер строки
%     * обрабатываемого текста, с которой начинается лексема,
%     * сведения о которой возвращены функцией current_lexem(). */
%    size_t lexem_begin_line_number();
%protected:
%    int                          state; /* текущее состояние текущего автомата */
%
%    Location_ptr                 loc;
%    char32_t*                    lexem_begin; /* указатель на начало лексемы */
%    char32_t                     ch;          /* текущий символ */
%
%    /* множество категорий символов, которым принадлежит
%     * текущий символ */
%    uint64_t                     char_categories;
%
%    /* промежуточное значение сведений о лексеме */
%    Lexem_type                   token;
%
%    /* номер строки, с которой начинается текущая лексема */
%    size_t                       lexem_begin_line;
%
%    /* указатель на класс, подсчитывающий количество ошибок: */
%    std::shared_ptr<Error_count> en;
%    /* указатель на префиксное дерево для идентификаторов: */
%    std::shared_ptr<Char_trie>   ids;
%    /* указатель на префиксное дерево для строк: */
%    std::shared_ptr<Char_trie>   strs;
%
%    /*буфер для записи обрабатываемого идентификатора или строки: */
%    std::u32string               buffer;
%};
%
%template<typename Lexem_type>
%Abstract_scaner<Lexem_type>::Abstract_scaner(Location_ptr location,
%                                             const Errors_and_tries& et){
%    ids = et.ids_trie; strs = et.strs_trie; en = et.ec;
%    loc = location;
%    lexem_begin = location->pcurrent_char;
%    lexem_begin_line = 1;
%}
%
%template<typename Lexem_type>
%void Abstract_scaner<Lexem_type>::back(){
%    loc->pcurrent_char = lexem_begin;
%    loc->current_line =  lexem_begin_line;
%}
%
%template<typename Lexem_type>
%size_t Abstract_scaner<Lexem_type>::lexem_begin_line_number(){
%    return lexem_begin_line;
%}
%#endif
%\end{minted}
%
%\chapter{Пример программы тестирования работы сгенерированного сканера}
%Наконец, приведём пример программы, тестирующей работу сгенерированного сканера.
%\begin{minted}{c++}
%#include <cstdlib>
%#include <cstdio>
%#include <memory>
%#include "../include/fsize.h"
%#include "../include/error_count.h"
%#include "../include/location.h"
%#include "../include/trie.h"
%#include "../include/scaner.h"
%#include "../include/char_conv.h"
%#include "../include/test_scaner.h"
%#include "../include/errors_and_tries.h"
%#include "../include/file_contents.h"
%#include "../include/char_trie.h"
%
%/* Функция, открывающая файл с тестовым текстом. Возвращает строку с текстом, если открыть 
%   файл удалось и размер файла не равен нулю, и пустую строку в противном случае. */
%std::u32string init_testing(const char* name){
%    auto contents = get_contents(name);
%    auto str      = contents.second;
%    switch(contents.first){
%        case Get_contents_return_code::Normal:
%            if(!str.length()){
%                puts("Длина файла равна нулю.");
%                return U"";
%            }else{
%                return utf8_to_u32string(str.c_str());
%            }
%            break;
%            
%        case Get_contents_return_code::Impossible_open:
%            puts("Невозможно открыть файл.");
%            return U"";
%            
%        case Get_contents_return_code::Read_error: 
%            puts("Ошибка при чтении файла.");
%            return U"";
%    }
%    return U"";
%}
%
%int main(int argc, char** argv) {
%    if(1 == argc){
%        puts("Не задан тестовый файл.");
%    }else{
%        std::u32string t = init_testing(argv[1]);
%        if(t.length()){
%            char32_t* p   = const_cast<char32_t*>(t.c_str());
%            auto      loc = std::make_shared<Location>(p);
%
%            Errors_and_tries etr;
%            etr.ec        = std::make_shared<Error_count>();
%            etr.ids_trie  = std::make_shared<Char_trie>();
%            etr.strs_trie = std::make_shared<Char_trie>();
%            auto sc       = std::make_shared<Scaner>(loc,  etr);
%            test_scaner(sc);
%        }
%    }
%    return 0;
%}
%\end{minted}
%
%Пример файлов \texttt{test_scaner.cpp} и \texttt{test_scaner.h}:
%\begin{minted}{c++}
%/* Пример файла test_scaner.cpp. */
%#include <cstdio>
%#include "../include/test_scaner.h"
%#include "../include/char_conv.h"
%
%/* Данный массив состоит из строковых литералов, представляющих собой заключённые
% * в кавычки идентификаторы из перечисления Lexem_code. Строки идут в том же
% * порядке, что и соответствующие идентификаторы перечисления Lexem_code. */
%
%static const char* lexem_names[] = {
%    "Nothing",             "UnknownLexem",       "Action",
%    "Opened_round_brack",  "Closed_round_brack", "Or",
%    "Kleene_closure",      "Positive_closure",   "Optional_member",
%    "Character",           "Begin_expression",   "End_expression",
%    "Class_Latin",         "Class_Letter",       "Class_Russian",
%    "Class_bdigits",       "Class_digits",       "Class_latin",
%    "Class_letter",        "Class_odigits",      "Class_russian",
%    "Class_xdigits",       "Class_ndq",          "Class_nsq",
%    "M_Class_Latin",       "M_Class_Letter",     "M_Class_Russian",
%    "M_Class_bdigits",     "M_Class_digits",     "M_Class_latin",
%    "M_Class_letter",      "M_Class_odigits",    "M_Class_russian",
%    "M_Class_xdigits",     "M_Class_ndq",        "M_Class_nsq"
%};
%
%void print_lexem(Expr_lexem_info li){
%    Lexem_code lc = li.code;
%    printf("%s", lexem_names[lc]);
%    if(Character == lc){
%        char32_t ch = li.c;
%        if(ch < ' '){
%            printf(" %u", ch);
%        }else{
%            std::string s = char32_to_utf8(ch);
%            printf(" '%s'",s.c_str());
%        }         
%    }
%    printf(" \n");
%}
%
%void test_scaner(std::shared_ptr<Expr_scaner> sc){
%    Lexem_info lexem;
%    do{
%        lexem = sc -> current_lexem();
%        print_lexem(lexem);
%    }while(lexem.code);
%}
%\end{minted}
%\begin{minted}{c++}
%/* Пример файла test_scaner.h. */
%#ifndef TEST_SCANER_H
%#define	TEST_SCANER_H
%#include <memory>
%#include "../include/scaner.h"
%void print_lexem(Lexem_info li);
%void test_scaner(std::shared_ptr<Scaner> sc);
%#endif	/* TEST_SCANER_H */
%\end{minted}

\newpage
\renewcommand{\bibname}{Список литературы}
\begin{thebibliography}{9}\addcontentsline{toc}{section}{Список литературы}
\bibitem{AhoLamSetiUllman} Ахо А., Лам М., Сети Р., Ульман Дж. Компиляторы: принципы, технологии и инструментарий. 2--е изд.: Пер. с англ. --- М.: Вильямс, 2008.

\bibitem{HopkroftMotvaniUllman} Хопкрофт Дж. Э., Мотвани Р., Ульман Дж. Введение в теорию автоматов, языков и вычислений.  2--е изд.: Пер. с англ. --- М.: Вильямс, 2002.

\bibitem{FridlJ} Фридл Дж. Регулярные выражения. 3--е изд: Пер. с англ. --- СПб.: Символ-Плюс, 2008.

\bibitem{Mozgovoj} Мозговой М.В. Классика программирования: алгоритмы, языки, автоматы, компиляторы. Практический подход. --- СПб.: Наука и техника, 2006.

\bibitem{Sverdlov} Свердлов С.З. Языки программирования и методы трансляции. --- СПб.: Питер, 2007.

\bibitem{Wirth-compiler} Вирт Н. Построение компиляторов. --- М.: ДМК Пресс, 2014.

\bibitem{Krenshow} Креншоу Дж. Давайте создадим компилятор! --- М.: 1995.

\bibitem{KnuthV3-1978} Кнут Д.Э. Искусство программирования для ЭВМ. Т.3. Сортировка и поиск.: Пер. с англ. --- М.: Мир, 1978.

\bibitem{KnuthV3} Кнут Д.Э. Искусство программирования. Т.3. Сортировка и поиск. 2--е изд.: Пер. с англ. --- М.: Вильямс, 2008.

\bibitem{AhoHopcroftUllman} Ахо А., Хопкрофт Дж., Ульман Дж. Структуры данных и алгоритмы.: Пер с англ. --- М.: Вильямс, 2000.
\end{thebibliography}
\end{document}